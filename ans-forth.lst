ca65 V2.19 - Git b2ae73879
Main file   : ans-forth.asm
Current file: ans-forth.asm

000000r 1               ;===============================================================================
000000r 1               ;     _    _   _ ____    _____          _   _       _  ___  _  __
000000r 1               ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
000000r 1               ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
000000r 1               ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
000000r 1               ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
000000r 1               ;
000000r 1               ; A Direct Threaded ANS Forth for the WDC 65C816
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               ; Copyright (C)2015-2016 HandCoded Software Ltd.
000000r 1               ; All rights reserved.
000000r 1               ;
000000r 1               ; This work is made available under the terms of the Creative Commons
000000r 1               ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
000000r 1               ; following URL to see the details.
000000r 1               ;
000000r 1               ; http://creativecommons.org/licenses/by-nc-sa/4.0/
000000r 1               ;
000000r 1               ;===============================================================================
000000r 1               ; Notes:
000000r 1               ;
000000r 1               ; This implementation is designed to run in the 65C816's native mode with both
000000r 1               ; the accumulator and index registers in 16-bit mode except when the word needs
000000r 1               ; 8-bit memory access.
000000r 1               ;
000000r 1               ; The DP register is used for the Forth data stack is values can be accessed
000000r 1               ; using the direct-page addressing modes. The code uses the same offsets as
000000r 1               ; would be used with the stack relative instructions (i.e <1, <3, etc.).
000000r 1               ;
000000r 1               ; The Y register holds the forth instruction pointer leaving X free for general
000000r 1               ; use in words. Some words push Y if they need an extra register.
000000r 1               ;
000000r 1               ; Some of the high-level definitions are based on Bradford J. Rodriguez's
000000r 1               ; CamelForth implementations.
000000r 1               ;
000000r 1               ;-------------------------------------------------------------------------------
000000r 1                               .include "ca65.inc"
000000r 2               .list on
000000r 2               .p816
000000r 2               .define code    .segment "CODE"
000000r 2               .define data    .segment "DATA"
000000r 2               .define db      .byte
000000r 2               .define ds      .res
000000r 2               .define dw      .word
000000r 2               .define else    .else
000000r 2               .define end     .end
000000r 2               .define endif   .endif
000000r 2               .define equ     :=
000000r 2               .define extern  .import
000000r 2               .define if      .if
000000r 2               .define include .include
000000r 2               .define page0   .segment "ZEROPAGE"
000000r 2               .define public  .export
000000r 2               .define set     .set
000000r 2               .define WORDL   .ident(.sprintf("WORD%d", WORDZ))
000000r 2               .feature labels_without_colons
000000r 2               .feature dollar_is_pc
000000r 2               .feature ubiquitous_idents
000000r 2               .macro longi enable
000000r 2                       .if .match(enable,"on")
000000r 2                               .i16
000000r 2                       .else
000000r 2                               .i8
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro longa enable
000000r 2                       .if .match(enable,"on")
000000r 2                               .a16
000000r 2                       .else
000000r 2                               .a8
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               longi off
000000r 1               longa off
000000r 1               
000000r 1                               include "w65c816.inc"
000000r 2               ;==============================================================================
000000r 2               ; __        ____  ____   ____ ___  _  __
000000r 2               ; \ \      / / /_| ___| / ___( _ )/ |/ /_
000000r 2               ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \
000000r 2               ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
000000r 2               ;    \_/\_/  \___/____/ \____\___/|_|\___/
000000r 2               ;
000000r 2               ; Western Design Center W65C816 device definitions
000000r 2               ;------------------------------------------------------------------------------
000000r 2               ; Copyright (C)2015 HandCoded Software Ltd.
000000r 2               ; All rights reserved.
000000r 2               ;
000000r 2               ; This work is made available under the terms of the Creative Commons
000000r 2               ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
000000r 2               ; following URL to see the details.
000000r 2               ;
000000r 2               ; http://creativecommons.org/licenses/by-nc-sa/4.0/
000000r 2               ;
000000r 2               ;===============================================================================
000000r 2               ; Notes:
000000r 2               ;
000000r 2               ; Various macros and definitions for the W65C816 microprocessor.
000000r 2               ;
000000r 2               ;===============================================================================
000000r 2               ; Revision History:
000000r 2               ;
000000r 2               ; 2015-12-18 AJ Initial version
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               ; $Id$
000000r 2               ;-------------------------------------------------------------------------------
000000r 2               
000000r 2               ;==============================================================================
000000r 2               ; Status Register Bits
000000r 2               ;------------------------------------------------------------------------------
000000r 2               
000000r 2               N_FLAG          equ     1<<7
000000r 2               V_FLAG          equ     1<<6
000000r 2               M_FLAG          equ     1<<5
000000r 2               X_FLAG          equ     1<<4
000000r 2               B_FLAG          equ     1<<4
000000r 2               D_FLAG          equ     1<<3
000000r 2               I_FLAG          equ     1<<2
000000r 2               Z_FLAG          equ     1<<1
000000r 2               C_FLAG          equ     1<<0
000000r 2               
000000r 2               ;==============================================================================
000000r 2               ; Macros
000000r 2               ;------------------------------------------------------------------------------
000000r 2               
000000r 2               ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
000000r 2               ; is fixed at $0100-$01ff.
000000r 2               
000000r 2               .macro          emulate
000000r 2                               sec
000000r 2                               xce
000000r 2               .endmacro
000000r 2               
000000r 2               ; Puts the processor in native mode. The size of the memory and index register
000000r 2               ; operations is not controlled by the M & X bits in the status register.
000000r 2               
000000r 2               .macro          native
000000r 2                               clc
000000r 2                               xce
000000r 2               .endmacro
000000r 2               
000000r 2               ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
000000r 2               
000000r 2               .macro          long_a
000000r 2                               rep     #M_FLAG
000000r 2                               .a16
000000r 2               .endmacro
000000r 2               
000000r 2               ; Resets the X bit making the index registers 16-bits wide
000000r 2               
000000r 2               .macro          long_i
000000r 2                               rep     #X_FLAG
000000r 2                               .i16
000000r 2               .endmacro
000000r 2               
000000r 2               ; Resets the M and X bits making the accumulator, memory accesses and index
000000r 2               ; registers 16-bits wide.
000000r 2               
000000r 2               .macro          long_ai
000000r 2                               rep     #M_FLAG|X_FLAG
000000r 2                               .a16
000000r 2                               .i16
000000r 2               .endmacro
000000r 2               
000000r 2               ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
000000r 2               
000000r 2               .macro          short_a
000000r 2                               sep     #M_FLAG
000000r 2                               .a8
000000r 2               .endmacro
000000r 2               
000000r 2               ; Sets the X bit making the index registers 8-bits wide.
000000r 2               
000000r 2               .macro          short_i
000000r 2                               sep     #X_FLAG
000000r 2                               .i8
000000r 2               .endmacro
000000r 2               
000000r 2               ; Sets the M & X bits making the accumulator, memory accesses and index
000000r 2               ; registers 8-bits wide.
000000r 2               
000000r 2               .macro          short_ai
000000r 2                               sep     #M_FLAG|X_FLAG
000000r 2                               .a8
000000r 2                               .i8
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               ;===============================================================================
000000r 1               ; Macros
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               
000000r 1               ; The LINK macro deposits the link section of a word header automatically
000000r 1               ; linking the new word to the last.
000000r 1               
000000r 1               WORDZ           set     0                       ; Word counter
000000r 1               WORD0           equ     0                       ; Null address for first word
000000r 1               
000000r 1               .macro LINK TYPE
000000r 1                               dw      WORDL                   ; Link
000000r 1                               db      TYPE                    ; Type
000000r 1               WORDZ           set     WORDZ+1
000000r 1               WORDL:
000000r 1               .endmacro
000000r 1               
000000r 1               ; Deposits a word header containing the name which is linked back to the
000000r 1               ; previous word.
000000r 1               ;
000000r 1               ; The WDC assembler does not handle string parameters to macros very well,
000000r 1               ; stopping at the first comma or space in them, so some headers must be
000000r 1               ; manually constructed.
000000r 1               
000000r 1               NORMAL          equ     $00
000000r 1               IMMEDIATE       equ     $80
000000r 1               
000000r 1               .macro HEADER LEN,NAME,TYPE
000000r 1                               LINK    TYPE
000000r 1                               db      LEN,NAME
000000r 1               .endmacro
000000r 1               
000000r 1               ; The CONTINUE macro is used at the end of a native word to invoke the next
000000r 1               ; word pointer.
000000r 1               
000000r 1               .macro CONTINUE
000000r 1                               tyx                             ; Copy IP to X
000000r 1                               iny
000000r 1                               iny
000000r 1                               jmp     (0,x)                   ; Then execute word
000000r 1               .endmacro
000000r 1               
000000r 1               .macro TRAILER
000000r 1               LAST_WORD       equ     WORDL
000000r 1               .endmacro
000000r 1               
000000r 1               ;===============================================================================
000000r 1               ; Definitions
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               
000000r 1               USER_SIZE       equ     22
000000r 1               DSTACK_SIZE     equ     128
000000r 1               RSTACK_SIZE     equ     128
000000r 1               
000000r 1               TO_IN_OFFSET    equ     0
000000r 1               BASE_OFFSET     equ     2
000000r 1               BLK_OFFSET      equ     4
000000r 1               DP_OFFSET       equ     6
000000r 1               LATEST_OFFSET   equ     8
000000r 1               SCR_OFFSET      equ     10
000000r 1               SOURCEID_OFFSET equ     12                      ; Input source flag
000000r 1               STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
000000r 1               BUFFER_OFFSET   equ     16                      ; Address of the input buffer
000000r 1               LENGTH_OFFSET   equ     18                      ; Length of the input buffer
000000r 1               HP_OFFSET       equ     20
000000r 1               
000000r 1               TIB_SIZE        equ     128
000000r 1               PAD_SIZE        equ     48
000000r 1               
000000r 1               ;===============================================================================
000000r 1               ; Data Areas
000000r 1               ;-------------------------------------------------------------------------------
000000r 1               
000000r 1                               page0
000000r 1               
000000r 1  xx xx xx xx  USER_AREA       ds      USER_SIZE               ; User Variables
000004r 1  xx xx xx xx  
000008r 1  xx xx xx xx  
000016r 1               
000016r 1               
000016r 1               DSTACK_START    equ     $0100
000016r 1               DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
000016r 1               
000016r 1               RSTACK_START    equ     $0180
000016r 1               RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
000016r 1               
000016r 1               
000016r 1                               data
000000r 1               
000000r 1  xx xx xx xx  TIB_AREA:       ds      TIB_SIZE                ; Terminal Input Buffer
000004r 1  xx xx xx xx  
000008r 1  xx xx xx xx  
0000B0r 1                               ds      PAD_SIZE                ; Pad area
0000B0r 1               PAD_AREA:       ds      0
0000B0r 1               
0000B0r 1               ;===============================================================================
0000B0r 1               ; Forth Entry Point
0000B0r 1               ;-------------------------------------------------------------------------------
0000B0r 1               
0000B0r 1               .segment "FORTH"
000000r 1               
000000r 1                               public  Start
000000r 1               Start:
000000r 1  18 FB                        native                          ; Go to native mode
000002r 1  C2 30                        long_ai                         ; And all 16-bit registers
000004r 1  A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
000007r 1  1B                           tcs
000008r 1  A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
00000Br 1  5B                           tcd
00000Cr 1               
00000Cr 1  A0 rr rr                     ldy     #COLD                   ; Then perform COLD start
00000Fr 1  BB C8 C8 7C                  CONTINUE
000013r 1  00 00        
000015r 1               
000015r 1  rr rr rr rr  COLD:
000019r 1  rr rr rr rr  
00001Dr 1  rr rr rr rr  
000041r 1                               dw      DECIMAL
000041r 1                               dw      ZERO
000041r 1                               dw      BLK
000041r 1                               dw      STORE
000041r 1                               dw      FALSE
000041r 1                               dw      STATE
000041r 1                               dw      STORE
000041r 1                               dw      DO_LITERAL,NEXT_WORD
000041r 1                               dw      DP
000041r 1                               dw      STORE
000041r 1                               dw      DO_LITERAL,LAST_WORD
000041r 1                               dw      LATEST
000041r 1                               dw      STORE
000041r 1                               dw      CR
000041r 1                               dw      CR
000041r 1                               dw      DO_TITLE
000041r 1                               dw      TYPE
000041r 1                               dw      CR
000041r 1                               dw      CR
000041r 1                               dw      ABORT
000041r 1               
000041r 1               ;===============================================================================
000041r 1               ; System/User Variables
000041r 1               ;-------------------------------------------------------------------------------
000041r 1               
000041r 1               ; #TIB ( -- a-addr )
000041r 1               ;
000041r 1               ; a-addr is the address of a cell containing the number of characters in the
000041r 1               ; terminal input buffer.
000041r 1               
000041r 1  00 00 00 04                  HEADER  4,"#TIB",NORMAL
000045r 1  23 54 49 42  
000049r 1  20 rr rr rr  HASH_TIB:       jsr     DO_CONSTANT
00004Dr 1  rr 7E 00     
000050r 1                               dw      $+2
000050r 1                               dw      TIB_SIZE-2
000050r 1               
000050r 1               ; >IN ( -- a-addr )
000050r 1               ;
000050r 1               ; a-addr is the address of a cell containing the offset in characters from the
000050r 1               ; start of the input buffer to the start of the parse area.
000050r 1               
000050r 1  rr rr 00 03                  HEADER  3,">IN",NORMAL
000054r 1  3E 49 4E     
000057r 1  20 rr rr 00  TO_IN:          jsr     DO_USER
00005Br 1  00           
00005Cr 1                               dw      TO_IN_OFFSET
00005Cr 1               
00005Cr 1               ; BASE ( -- a-addr )
00005Cr 1               ;
00005Cr 1               ; a-addr is the address of a cell containing the current number-conversion
00005Cr 1               ; radix {{2...36}}.
00005Cr 1               
00005Cr 1  rr rr 00 04                  HEADER  4,"BASE",NORMAL
000060r 1  42 41 53 45  
000064r 1  20 rr rr 02  BASE:           jsr     DO_USER
000068r 1  00           
000069r 1                               dw      BASE_OFFSET
000069r 1               
000069r 1               ; BLK ( -- a-addr )
000069r 1               ;
000069r 1               ; a-addr is the address of a cell containing zero or the number of the mass-
000069r 1               ; storage block being interpreted. If BLK contains zero, the input source is
000069r 1               ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
000069r 1               ; ambiguous condition exists if a program directly alters the contents of BLK.
000069r 1               
000069r 1  rr rr 00 03                  HEADER  3,"BLK",NORMAL
00006Dr 1  42 4C 4B     
000070r 1  20 rr rr 04  BLK:            jsr     DO_USER
000074r 1  00           
000075r 1                               dw      BLK_OFFSET
000075r 1               
000075r 1               ; (BUFFER)
000075r 1               
000075r 1  20 rr rr 10  BUFFER:         jsr     DO_USER
000079r 1  00           
00007Ar 1                               dw      BUFFER_OFFSET
00007Ar 1               
00007Ar 1               ; DP ( -- a-addr )
00007Ar 1               ;
00007Ar 1               ; Dictionary Pointer
00007Ar 1               
00007Ar 1  rr rr 00 02                  HEADER  2,"DP",NORMAL
00007Er 1  44 50        
000080r 1  20 rr rr 06  DP:             jsr     DO_USER
000084r 1  00           
000085r 1                               dw      DP_OFFSET
000085r 1               
000085r 1               ; HP ( -- a-addr )
000085r 1               ;
000085r 1               ; Hold Pointer
000085r 1               
000085r 1  20 rr rr 14  HP:             jsr     DO_USER
000089r 1  00           
00008Ar 1                               dw      HP_OFFSET
00008Ar 1               
00008Ar 1               ; LATEST ( -- a-addr )
00008Ar 1               
00008Ar 1  rr rr 00 06                  HEADER  6,"LATEST",NORMAL
00008Er 1  4C 41 54 45  
000092r 1  53 54        
000094r 1  20 rr rr 08  LATEST:         jsr     DO_USER
000098r 1  00           
000099r 1                               dw      LATEST_OFFSET
000099r 1               
000099r 1               ; (LENGTH)
000099r 1               
000099r 1  20 rr rr 12  LENGTH:         jsr     DO_USER
00009Dr 1  00           
00009Er 1                               dw      LENGTH_OFFSET
00009Er 1               
00009Er 1               ; SCR ( -- a-addr )
00009Er 1               ;
00009Er 1               ; a-addr is the address of a cell containing the block number of the block most
00009Er 1               ; recently LISTed.
00009Er 1               
00009Er 1  rr rr 00 03                  HEADER  3,"SCR",NORMAL
0000A2r 1  53 43 52     
0000A5r 1  20 rr rr 0A  SCR:            jsr     DO_USER
0000A9r 1  00           
0000AAr 1                               dw      SCR_OFFSET
0000AAr 1               
0000AAr 1               ; (SOURCE-ID)
0000AAr 1               
0000AAr 1  20 rr rr 0C  SOURCEID:       jsr     DO_USER
0000AEr 1  00           
0000AFr 1                               dw      SOURCEID_OFFSET
0000AFr 1               
0000AFr 1               ; STATE ( -- a-addr )
0000AFr 1               ;
0000AFr 1               ; a-addr is the address of a cell containing the compilation-state flag. STATE
0000AFr 1               ; is true when in compilation state, false otherwise. The true value in STATE
0000AFr 1               ; is non-zero, but is otherwise implementation-defined.
0000AFr 1               
0000AFr 1  rr rr 00 05                  HEADER  5,"STATE",NORMAL
0000B3r 1  53 54 41 54  
0000B7r 1  45           
0000B8r 1  20 rr rr 0E  STATE:          jsr     DO_USER
0000BCr 1  00           
0000BDr 1                               dw      STATE_OFFSET
0000BDr 1               
0000BDr 1               ; TIB ( -- c-addr )
0000BDr 1               ;
0000BDr 1               ; c-addr is the address of the terminal input buffer.
0000BDr 1               
0000BDr 1  rr rr 00 03                  HEADER  3,"TIB",NORMAL
0000C1r 1  54 49 42     
0000C4r 1  20 rr rr rr  TIB:            jsr     DO_CONSTANT
0000C8r 1  rr           
0000C9r 1                               dw      TIB_AREA
0000C9r 1               
0000C9r 1               ;===============================================================================
0000C9r 1               ; Constants
0000C9r 1               ;-------------------------------------------------------------------------------
0000C9r 1               
0000C9r 1               ; 0 ( -- 0 )
0000C9r 1               ;
0000C9r 1               ; Push the constant value zero on the stack
0000C9r 1               
0000C9r 1  rr rr 00 01                  HEADER  1,"0",NORMAL
0000CDr 1  30           
0000CEr 1               ZERO:
0000CEr 1  7B                           tdc
0000CFr 1  3A                           dec     a                       ; Make space on the stack
0000D0r 1  3A                           dec     a
0000D1r 1  5B                           tcd
0000D2r 1  64 01                        stz     <1                      ; And create a zero value
0000D4r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0000D8r 1  00 00        
0000DAr 1               
0000DAr 1               ; BL ( -- char )
0000DAr 1               ;
0000DAr 1               ; char is the character value for a space.
0000DAr 1               
0000DAr 1  rr rr 00 02                  HEADER  2,"BL",NORMAL
0000DEr 1  42 4C        
0000E0r 1               BL:
0000E0r 1  7B                           tdc
0000E1r 1  3A                           dec     a                       ; Make space on the stack
0000E2r 1  3A                           dec     a
0000E3r 1  5B                           tcd
0000E4r 1  A9 20 00                     lda     #' '                    ; And save a space value
0000E7r 1  85 01                        sta     <1
0000E9r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0000EDr 1  00 00        
0000EFr 1               
0000EFr 1               ; FALSE ( -- false )
0000EFr 1               ;
0000EFr 1               ; Return a false flag.
0000EFr 1               
0000EFr 1  rr rr 00 05                  HEADER  5,"FALSE",NORMAL
0000F3r 1  46 41 4C 53  
0000F7r 1  45           
0000F8r 1               FALSE:
0000F8r 1  7B                           tdc
0000F9r 1  3A                           dec     a                       ; Make space on the stack
0000FAr 1  3A                           dec     a
0000FBr 1  5B                           tcd
0000FCr 1  64 01                        stz     <1                      ; And create a false value
0000FEr 1  BB C8 C8 7C                  CONTINUE                        ; Done
000102r 1  00 00        
000104r 1               
000104r 1               ; TRUE ( -- true )
000104r 1               ;
000104r 1               ; Return a true flag, a single-cell value with all bits set.
000104r 1               
000104r 1  rr rr 00 04                  HEADER  4,"TRUE",NORMAL
000108r 1  54 52 55 45  
00010Cr 1               TRUE:
00010Cr 1  7B                           tdc
00010Dr 1  3A                           dec     a                       ; Make space on the stack
00010Er 1  3A                           dec     a
00010Fr 1  5B                           tcd
000110r 1  64 01                        stz     <1                      ; And create a true value
000112r 1  C6 01                        dec     <1
000114r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000118r 1  00 00        
00011Ar 1               
00011Ar 1               ;===============================================================================
00011Ar 1               ; Radix
00011Ar 1               ;-------------------------------------------------------------------------------
00011Ar 1               
00011Ar 1               ; DECIMAL ( -- )
00011Ar 1               ;
00011Ar 1               ; Set the numeric conversion radix to ten (decimal).
00011Ar 1               
00011Ar 1  rr rr 00 07                  HEADER  7,"DECIMAL",NORMAL
00011Er 1  44 45 43 49  
000122r 1  4D 41 4C     
000125r 1  20 rr rr rr  DECIMAL:        jsr     DO_COLON
000129r 1  rr 0A 00 rr  
00012Dr 1  rr rr rr rr  
000132r 1                               dw      DO_LITERAL,10
000132r 1                               dw      BASE
000132r 1                               dw      STORE
000132r 1                               dw      EXIT
000132r 1               
000132r 1               ; HEX ( -- )
000132r 1               ;
000132r 1               ; Set contents of BASE to sixteen.
000132r 1               
000132r 1  rr rr 00 03                  HEADER  3,"HEX",NORMAL
000136r 1  48 45 58     
000139r 1  20 rr rr rr  HEX:            jsr     DO_COLON
00013Dr 1  rr 10 00 rr  
000141r 1  rr rr rr rr  
000146r 1                               dw      DO_LITERAL,16
000146r 1                               dw      BASE
000146r 1                               dw      STORE
000146r 1                               dw      EXIT
000146r 1               
000146r 1               ;===============================================================================
000146r 1               ; Memory Operations
000146r 1               ;-------------------------------------------------------------------------------
000146r 1               
000146r 1               ; ! ( x a-addr -- )
000146r 1               ;
000146r 1               ; Store x at a-addr.
000146r 1               
000146r 1  rr rr 00 01                  HEADER  1,"!",NORMAL
00014Ar 1  21           
00014Br 1               STORE:
00014Br 1  A5 03                        lda     <3                      ; Fetch data value
00014Dr 1  92 01                        sta     (1)                     ; .. and store
00014Fr 1  7B                           tdc                             ; Clean up data stack
000150r 1  1A                           inc     a
000151r 1  1A                           inc     a
000152r 1  1A                           inc     a
000153r 1  1A                           inc     a
000154r 1  5B                           tcd
000155r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000159r 1  00 00        
00015Br 1               
00015Br 1               ; +! ( n|u a-addr -- )
00015Br 1               ;
00015Br 1               ; Add n|u to the single-cell number at a-addr.
00015Br 1               
00015Br 1  rr rr 00 02                  HEADER  2,"+!",NORMAL
00015Fr 1  2B 21        
000161r 1               PLUS_STORE:
000161r 1  18                           clc
000162r 1  A5 03                        lda     <3                      ; Fetch data value
000164r 1  72 01                        adc     (1)
000166r 1  92 01                        sta     (1)
000168r 1  7B                           tdc                             ; Clean up data stack
000169r 1  1A                           inc     a
00016Ar 1  1A                           inc     a
00016Br 1  1A                           inc     a
00016Cr 1  1A                           inc     a
00016Dr 1  5B                           tcd
00016Er 1  BB C8 C8 7C                  CONTINUE                        ; Done
000172r 1  00 00        
000174r 1               
000174r 1               ; , ( x -- )
000174r 1               ;
000174r 1               ; Reserve one cell of data space and store x in the cell. If the data-space
000174r 1               ; pointer is aligned when , begins execution, it will remain aligned when ,
000174r 1               ; finishes execution. An ambiguous condition exists if the data-space pointer
000174r 1               ; is not aligned prior to execution of ,.
000174r 1               ;
000174r 1               ; In this implementation is its defined as:
000174r 1               ;
000174r 1               ;   HERE ! 1 CELLS ALLOT
000174r 1               
000174r 1  rr rr 00 01                  LINK    NORMAL
000178r 1  2C           
000179r 1                               db      1,","
000179r 1  20 rr rr rr  COMMA:          jsr     DO_COLON
00017Dr 1  rr rr rr rr  
000181r 1  rr 01 00 rr  
00018Ar 1                               dw      HERE
00018Ar 1                               dw      STORE
00018Ar 1                               dw      DO_LITERAL,1
00018Ar 1                               dw      CELLS
00018Ar 1                               dw      ALLOT
00018Ar 1                               dw      EXIT
00018Ar 1               
00018Ar 1               ; 2! ( x1 x2 a-addr -- )
00018Ar 1               ;
00018Ar 1               ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
00018Ar 1               ; consecutive cell.
00018Ar 1               ;
00018Ar 1               ; In this implementation is its defined as:
00018Ar 1               ;
00018Ar 1               ;   SWAP OVER ! CELL+ !.
00018Ar 1               
00018Ar 1  rr rr 00 02                  HEADER  2,"2!",NORMAL
00018Er 1  32 21        
000190r 1  20 rr rr rr  TWO_STORE:      jsr     DO_COLON
000194r 1  rr rr rr rr  
000198r 1  rr rr rr rr  
00019Fr 1                               dw      SWAP
00019Fr 1                               dw      OVER
00019Fr 1                               dw      STORE
00019Fr 1                               dw      CELL_PLUS
00019Fr 1                               dw      STORE
00019Fr 1                               dw      EXIT
00019Fr 1               
00019Fr 1               ; 2@ ( a-addr -- x1 x2 )
00019Fr 1               ;
00019Fr 1               ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
00019Fr 1               ; the next consecutive cell.
00019Fr 1               ;
00019Fr 1               ; In this implementation is its defined as:
00019Fr 1               ;
00019Fr 1               ;   DUP CELL+ @ SWAP @
00019Fr 1               
00019Fr 1  rr rr 00 02                  HEADER  2,"2@",NORMAL
0001A3r 1  32 40        
0001A5r 1  20 rr rr rr  TWO_FETCH:      jsr     DO_COLON
0001A9r 1  rr rr rr rr  
0001ADr 1  rr rr rr rr  
0001B4r 1                               dw      DUP
0001B4r 1                               dw      CELL_PLUS
0001B4r 1                               dw      FETCH
0001B4r 1                               dw      SWAP
0001B4r 1                               dw      FETCH
0001B4r 1                               dw      EXIT
0001B4r 1               
0001B4r 1               ; @ ( a-addr -- x )
0001B4r 1               ;
0001B4r 1               ; x is the value stored at a-addr.
0001B4r 1               
0001B4r 1  rr rr 00 01                  HEADER  1,"@",NORMAL
0001B8r 1  40           
0001B9r 1               FETCH:
0001B9r 1  B2 01                        lda     (1)                     ; Fetch from memory
0001BBr 1  85 01                        sta     <1                      ; .. and replace top value
0001BDr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0001C1r 1  00 00        
0001C3r 1               
0001C3r 1               ; ALLOT ( n -- )
0001C3r 1               ;
0001C3r 1               ; If n is greater than zero, reserve n address units of data space. If n is
0001C3r 1               ; less than zero, release |n| address units of data space. If n is zero, leave
0001C3r 1               ; the data-space pointer unchanged.
0001C3r 1               ;
0001C3r 1               ; In this implementation its is defined as:
0001C3r 1               ;
0001C3r 1               ;   DP +!
0001C3r 1               
0001C3r 1  rr rr 00 05                  HEADER  5,"ALLOT",NORMAL
0001C7r 1  41 4C 4C 4F  
0001CBr 1  54           
0001CCr 1  20 rr rr rr  ALLOT:          jsr     DO_COLON
0001D0r 1  rr rr rr rr  
0001D4r 1  rr           
0001D5r 1                               dw      DP
0001D5r 1                               dw      PLUS_STORE
0001D5r 1                               dw      EXIT
0001D5r 1               
0001D5r 1               ; C! ( char c-addr -- )
0001D5r 1               ;
0001D5r 1               ; Store char at c-addr. When character size is smaller than cell size, only the
0001D5r 1               ; number of low-order bits corresponding to character size are transferred.
0001D5r 1               
0001D5r 1  rr rr 00 02                  HEADER  2,"C!",NORMAL
0001D9r 1  43 21        
0001DBr 1               C_STORE:
0001DBr 1  A5 03                        lda     <3                      ; Fetch the data value
0001DDr 1  E2 20                        short_a
0001DFr 1  92 01                        sta     (1)                     ; And store it
0001E1r 1  C2 20                        long_a
0001E3r 1  7B                           tdc                             ; Clean up the stack
0001E4r 1  1A                           inc     a
0001E5r 1  1A                           inc     a
0001E6r 1  1A                           inc     a
0001E7r 1  1A                           inc     a
0001E8r 1  5B                           tcd
0001E9r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0001EDr 1  00 00        
0001EFr 1               
0001EFr 1               ; C, ( char -- )
0001EFr 1               ;
0001EFr 1               ; Reserve space for one character in the data space and store char in the
0001EFr 1               ; space. If the data-space pointer is character aligned when C, begins
0001EFr 1               ; execution, it will remain character aligned when C, finishes execution.
0001EFr 1               ; An ambiguous condition exists if the data-space pointer is not character-
0001EFr 1               ; aligned prior to execution of C,
0001EFr 1               ;
0001EFr 1               ;   HERE C! 1 CHARS ALLOT
0001EFr 1               
0001EFr 1  rr rr 00 02                  LINK    NORMAL
0001F3r 1  43 2C        
0001F5r 1                               db      2,"C,"
0001F5r 1  20 rr rr rr  C_COMMA:        jsr     DO_COLON
0001F9r 1  rr rr rr rr  
0001FDr 1  rr 01 00 rr  
000206r 1                               dw      HERE
000206r 1                               dw      C_STORE
000206r 1                               dw      DO_LITERAL,1
000206r 1                               dw      CHARS
000206r 1                               dw      ALLOT
000206r 1                               dw      EXIT
000206r 1               
000206r 1               ; C@ ( c-addr -- char )
000206r 1               ;
000206r 1               ; Fetch the character stored at c-addr. When the cell size is greater than
000206r 1               ; character size, the unused high-order bits are all zeroes.
000206r 1               
000206r 1  rr rr 00 02                  HEADER  2,"C@",NORMAL
00020Ar 1  43 40        
00020Cr 1               C_FETCH:
00020Cr 1  E2 20                        short_a
00020Er 1  B2 01                        lda     (1)                     ; Fetch the data byte
000210r 1  85 01                        sta     <1                      ; .. and replace stack value
000212r 1  64 02                        stz     <2
000214r 1  C2 20                        long_a
000216r 1  BB C8 C8 7C                  CONTINUE                        ; Done
00021Ar 1  00 00        
00021Cr 1               
00021Cr 1               ; HERE ( -- addr )
00021Cr 1               ;
00021Cr 1               ; addr is the data-space pointer.
00021Cr 1               
00021Cr 1  rr rr 00 04                  HEADER  4,"HERE",NORMAL
000220r 1  48 45 52 45  
000224r 1  20 rr rr rr  HERE:           jsr     DO_COLON
000228r 1  rr rr rr rr  
00022Cr 1  rr           
00022Dr 1                               dw      DP
00022Dr 1                               dw      FETCH
00022Dr 1                               dw      EXIT
00022Dr 1               
00022Dr 1               ;===============================================================================
00022Dr 1               ; Alignment
00022Dr 1               ;-------------------------------------------------------------------------------
00022Dr 1               
00022Dr 1               ; ALIGN ( -- )
00022Dr 1               ;
00022Dr 1               ; If the data-space pointer is not aligned, reserve enough space to align it.
00022Dr 1               
00022Dr 1  rr rr 00 05                  HEADER  5,"ALIGN",NORMAL
000231r 1  41 4C 49 47  
000235r 1  4E           
000236r 1               ALIGN:
000236r 1  BB C8 C8 7C                  CONTINUE                        ; Done
00023Ar 1  00 00        
00023Cr 1               
00023Cr 1               ; ALIGNED ( addr -- a-addr )
00023Cr 1               ;
00023Cr 1               ; a-addr is the first aligned address greater than or equal to addr.
00023Cr 1               
00023Cr 1  rr rr 00 07                  HEADER  7,"ALIGNED",NORMAL
000240r 1  41 4C 49 47  
000244r 1  4E 45 44     
000247r 1               ALIGNED:
000247r 1  BB C8 C8 7C                  CONTINUE                        ; Done
00024Br 1  00 00        
00024Dr 1               
00024Dr 1               ; CELL+ ( a-addr1 -- a-addr2 )
00024Dr 1               ;
00024Dr 1               ; Add the size in address units of a cell to a-addr1, giving a-addr2.
00024Dr 1               
00024Dr 1  rr rr 00 05                  HEADER  5,"CELL+",NORMAL
000251r 1  43 45 4C 4C  
000255r 1  2B           
000256r 1               CELL_PLUS:
000256r 1  E6 01                        inc     <1                      ; Bump the address by two
000258r 1  E6 01                        inc     <1
00025Ar 1  BB C8 C8 7C                  CONTINUE                        ; Done
00025Er 1  00 00        
000260r 1               
000260r 1               ; CELLS ( n1 -- n2 )
000260r 1               ;
000260r 1               ; n2 is the size in address units of n1 cells.
000260r 1               
000260r 1  rr rr 00 05                  HEADER  5,"CELLS",NORMAL
000264r 1  43 45 4C 4C  
000268r 1  53           
000269r 1               CELLS:
000269r 1  06 01                        asl     <1                      ; Two bytes per cell
00026Br 1  BB C8 C8 7C                  CONTINUE                        ; Done
00026Fr 1  00 00        
000271r 1               
000271r 1               ; CHAR+ ( c-addr1 -- c-addr2 )
000271r 1               ;
000271r 1               ; Add the size in address units of a character to c-addr1, giving c-addr2.
000271r 1               
000271r 1  rr rr 00 05                  HEADER  5,"CHAR+",NORMAL
000275r 1  43 48 41 52  
000279r 1  2B           
00027Ar 1               CHAR_PLUS:
00027Ar 1  E6 01                        inc     <1                      ; Bump the address by one
00027Cr 1  BB C8 C8 7C                  CONTINUE                        ; Done
000280r 1  00 00        
000282r 1               
000282r 1               ; CHAR- ( c-addr1 -- c-addr2 )
000282r 1               ;
000282r 1               ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
000282r 1               
000282r 1  rr rr 00 05                  HEADER  5,"CHAR-",NORMAL
000286r 1  43 48 41 52  
00028Ar 1  2D           
00028Br 1               CHAR_MINUS:
00028Br 1  C6 01                        dec     <1
00028Dr 1  BB C8 C8 7C                  CONTINUE                        ; Done
000291r 1  00 00        
000293r 1               
000293r 1               ; CHARS ( n1 -- n2 )
000293r 1               ;
000293r 1               ; n2 is the size in address units of n1 characters.
000293r 1               
000293r 1  rr rr 00 05                  HEADER  5,"CHARS",NORMAL
000297r 1  43 48 41 52  
00029Br 1  53           
00029Cr 1               CHARS:
00029Cr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0002A0r 1  00 00        
0002A2r 1               
0002A2r 1               ;===============================================================================
0002A2r 1               ; Stack Operations
0002A2r 1               ;-------------------------------------------------------------------------------
0002A2r 1               
0002A2r 1               ; 2DROP ( x1 x2 -- )
0002A2r 1               ;
0002A2r 1               ; Drop cell pair x1 x2 from the stack.
0002A2r 1               
0002A2r 1  rr rr 00 05                  HEADER  5,"2DROP",NORMAL
0002A6r 1  32 44 52 4F  
0002AAr 1  50           
0002ABr 1               TWO_DROP:
0002ABr 1  7B                           tdc                             ; Removed two words from stack
0002ACr 1  1A                           inc     a
0002ADr 1  1A                           inc     a
0002AEr 1  1A                           inc     a
0002AFr 1  1A                           inc     a
0002B0r 1  5B                           tcd
0002B1r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0002B5r 1  00 00        
0002B7r 1               
0002B7r 1               ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
0002B7r 1               ;
0002B7r 1               ; Duplicate cell pair x1 x2.
0002B7r 1               
0002B7r 1  rr rr 00 04                  HEADER  4,"2DUP",NORMAL
0002BBr 1  32 44 55 50  
0002BFr 1               TWO_DUP:
0002BFr 1  7B                           tdc                             ; Make space for new value
0002C0r 1  3A                           dec     a
0002C1r 1  3A                           dec     a
0002C2r 1  3A                           dec     a
0002C3r 1  3A                           dec     a
0002C4r 1  5B                           tcd
0002C5r 1  A5 05                        lda     <5                      ; Copy top two values
0002C7r 1  85 01                        sta     <1
0002C9r 1  A5 07                        lda     <7
0002CBr 1  85 03                        sta     <3
0002CDr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0002D1r 1  00 00        
0002D3r 1               
0002D3r 1               ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
0002D3r 1               ;
0002D3r 1               ; Copy cell pair x1 x2 to the top of the stack.
0002D3r 1               
0002D3r 1  rr rr 00 05                  HEADER  5,"2OVER",NORMAL
0002D7r 1  32 4F 56 45  
0002DBr 1  52           
0002DCr 1               TWO_OVER:
0002DCr 1  7B                           tdc                             ; Make space for new value
0002DDr 1  3A                           dec     a
0002DEr 1  3A                           dec     a
0002DFr 1  3A                           dec     a
0002E0r 1  3A                           dec     a
0002E1r 1  5B                           tcd
0002E2r 1  A5 09                        lda     <9                      ; Ciopy top two values
0002E4r 1  85 01                        sta     <1
0002E6r 1  A5 0B                        lda     <11
0002E8r 1  85 03                        sta     <3
0002EAr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0002EEr 1  00 00        
0002F0r 1               
0002F0r 1               ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
0002F0r 1               ;
0002F0r 1               ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
0002F0r 1               ; the top of the stack.
0002F0r 1               
0002F0r 1  rr rr 00 04                  HEADER  4,"2ROT",NORMAL
0002F4r 1  32 52 4F 54  
0002F8r 1               TWO_ROT:
0002F8r 1  A5 0B                        lda     <11                     ; Save x1
0002FAr 1  48                           pha
0002FBr 1  A5 09                        lda     <9                      ; Save x2
0002FDr 1  48                           pha
0002FEr 1  A5 07                        lda     <7                      ; Move x3
000300r 1  85 0B                        sta     <11
000302r 1  A5 05                        lda     <5                      ; Move x4
000304r 1  85 09                        sta     <9
000306r 1  A5 03                        lda     <3                      ; Move x5
000308r 1  85 07                        sta     <7
00030Ar 1  A5 01                        lda     <1                      ; Move x6
00030Cr 1  85 05                        sta     <5
00030Er 1  68                           pla                             ; Restore x2
00030Fr 1  85 01                        sta     <1
000311r 1  68                           pla                             ; Restore x1
000312r 1  85 03                        sta     <3
000314r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000318r 1  00 00        
00031Ar 1               
00031Ar 1               ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
00031Ar 1               ;
00031Ar 1               ; Exchange the top two cell pairs.
00031Ar 1               
00031Ar 1  rr rr 00 05                  HEADER  5,"2SWAP",NORMAL
00031Er 1  32 53 57 41  
000322r 1  50           
000323r 1               TWO_SWAP:
000323r 1  A5 03                        lda     <3                      ; Save x3
000325r 1  48                           pha
000326r 1  A5 01                        lda     <1                      ; Save x4
000328r 1  48                           pha
000329r 1  A5 07                        lda     <7                      ; Move x1
00032Br 1  85 03                        sta     <3
00032Dr 1  A5 05                        lda     <5                      ; Move x2
00032Fr 1  85 01                        sta     <1
000331r 1  68                           pla                             ; Move x4
000332r 1  85 05                        sta     <5
000334r 1  68                           pla                             ; Move x3
000335r 1  85 07                        sta     <7
000337r 1  BB C8 C8 7C                  CONTINUE                        ; Done
00033Br 1  00 00        
00033Dr 1               
00033Dr 1               ; ?DUP ( x -- 0 | x x )
00033Dr 1               ;
00033Dr 1               ; Duplicate x if it is non-zero.
00033Dr 1               
00033Dr 1  rr rr 00 04                  HEADER  4,"?DUP",NORMAL
000341r 1  3F 44 55 50  
000345r 1               QUERY_DUP:
000345r 1  A5 01                        lda     <1                      ; Fetch top value
000347r 1  D0 39                        bne     DUP                     ; Non-zero value?
000349r 1  BB C8 C8 7C                  CONTINUE                        ; Done
00034Dr 1  00 00        
00034Fr 1               
00034Fr 1               ; DEPTH ( -- +n )
00034Fr 1               ;
00034Fr 1               ; +n is the number of single-cell values contained in the data stack before +n
00034Fr 1               ; was placed on the stack.
00034Fr 1               
00034Fr 1  rr rr 00 05                  HEADER  5,"DEPTH",NORMAL
000353r 1  44 45 50 54  
000357r 1  48           
000358r 1  20 rr rr rr  DEPTH:          jsr     DO_COLON
00035Cr 1  rr rr rr 7F  
000360r 1  01 rr rr rr  
000369r 1                               dw      AT_DP
000369r 1                               dw      DO_LITERAL,DSTACK_END-1
000369r 1                               dw      SWAP
000369r 1                               dw      MINUS
000369r 1                               dw      TWO_SLASH
000369r 1                               dw      EXIT
000369r 1               
000369r 1               ; DROP ( x -- )
000369r 1               ;
000369r 1               ; Remove x from the stack.
000369r 1               
000369r 1  rr rr 00 04                  HEADER  4,"DROP",NORMAL
00036Dr 1  44 52 4F 50  
000371r 1               DROP:
000371r 1  7B                           tdc                             ; Drop the top value
000372r 1  1A                           inc     a
000373r 1  1A                           inc     a
000374r 1  5B                           tcd
000375r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000379r 1  00 00        
00037Br 1               
00037Br 1               ; DUP ( x -- x x )
00037Br 1               ;
00037Br 1               ; Duplicate x.
00037Br 1               
00037Br 1  rr rr 00 03                  HEADER  3,"DUP",NORMAL
00037Fr 1  44 55 50     
000382r 1               DUP:
000382r 1  7B                           tdc
000383r 1  3A                           dec     a
000384r 1  3A                           dec     a
000385r 1  5B                           tcd
000386r 1  A5 03                        lda     <3                      ; Fetch top value
000388r 1  85 01                        sta     <1                      ; And make a copy
00038Ar 1  BB C8 C8 7C                  CONTINUE                        ; Done
00038Er 1  00 00        
000390r 1               
000390r 1               ; NIP ( x1 x2 -- x2 )
000390r 1               ;
000390r 1               ; Drop the first item below the top of stack.
000390r 1               
000390r 1  rr rr 00 03                  HEADER  3,"NIP",NORMAL
000394r 1  4E 49 50     
000397r 1               NIP:
000397r 1  A5 01                        lda     <1                      ; Copy x2 over x1
000399r 1  85 03                        sta     <3
00039Br 1  80 D4                        bra     DROP
00039Dr 1               
00039Dr 1               ; OVER ( x1 x2 -- x1 x2 x1 )
00039Dr 1               ;
00039Dr 1               ; Place a copy of x1 on top of the stack.
00039Dr 1               
00039Dr 1  rr rr 00 04                  HEADER  4,"OVER",NORMAL
0003A1r 1  4F 56 45 52  
0003A5r 1               OVER:
0003A5r 1  7B                           tdc
0003A6r 1  3A                           dec     a
0003A7r 1  3A                           dec     a
0003A8r 1  5B                           tcd
0003A9r 1  A5 05                        lda     <5                      ; Fetch second value
0003ABr 1  85 01                        sta     <1                      ; And make a copy
0003ADr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0003B1r 1  00 00        
0003B3r 1               
0003B3r 1               ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
0003B3r 1               ;
0003B3r 1               ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
0003B3r 1               ; if there are less than u+2 items on the stack before PICK is executed.
0003B3r 1               
0003B3r 1  rr rr 00 04                  HEADER  4,"PICK",NORMAL
0003B7r 1  50 49 43 4B  
0003BBr 1               PICK:
0003BBr 1  A5 01                        lda     <1                      ; Fetch the index
0003BDr 1  0A                           asl     a
0003BEr 1  AA                           tax
0003BFr 1  B5 03                        lda     <3,x                    ; Load the target value
0003C1r 1  85 01                        sta     <1                      ; .. and save
0003C3r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0003C7r 1  00 00        
0003C9r 1               
0003C9r 1               ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
0003C9r 1               ;
0003C9r 1               ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
0003C9r 1               ; exists if there are less than u+2 items on the stack before ROLL is executed.
0003C9r 1               
0003C9r 1  rr rr 00 04                  HEADER  4,"ROLL",NORMAL
0003CDr 1  52 4F 4C 4C  
0003D1r 1               ROLL:
0003D1r 1  06 01                        asl     <1                      ; Convert count to index
0003D3r 1  A6 01                        ldx     <1
0003D5r 1  F0 0E                        beq     ROLL_2                  ; Zero? Nothing to do
0003D7r 1  B5 03                        lda     <3,x                    ; Save the final value
0003D9r 1  48                           pha
0003DAr 1  B5 01        ROLL_1:         lda     <1,x                    ; Move x-1 to x
0003DCr 1  95 03                        sta     <3,x
0003DEr 1  CA                           dex                             ; And repeat
0003DFr 1  CA                           dex
0003E0r 1  D0 F8                        bne     ROLL_1
0003E2r 1  68                           pla                             ; Recover the new top value
0003E3r 1  85 03                        sta     <3
0003E5r 1  4C rr rr     ROLL_2:         jmp     DROP                    ; Drop the count
0003E8r 1               
0003E8r 1               ; ROT ( x1 x2 x3 -- x2 x3 x1 )
0003E8r 1               ;
0003E8r 1               ; Rotate the top three stack entries.
0003E8r 1               
0003E8r 1  rr rr 00 03                  HEADER  3,"ROT",NORMAL
0003ECr 1  52 4F 54     
0003EFr 1               ROT:
0003EFr 1  A6 05                        ldx     <5                      ; Save x1
0003F1r 1  A5 03                        lda     <3                      ; Move x2
0003F3r 1  85 05                        sta     <5
0003F5r 1  A5 01                        lda     <1                      ; Move x3
0003F7r 1  85 03                        sta     <3
0003F9r 1  86 01                        stx     <1                      ; Restore x1
0003FBr 1  BB C8 C8 7C                  CONTINUE
0003FFr 1  00 00        
000401r 1               
000401r 1               ; SWAP ( x1 x2 -- x2 x1 )
000401r 1               ;
000401r 1               ; Exchange the top two stack items.
000401r 1               
000401r 1  rr rr 00 04                  HEADER  4,"SWAP",NORMAL
000405r 1  53 57 41 50  
000409r 1               SWAP:
000409r 1  A5 01                        lda     <1                      ; Switch top two words
00040Br 1  A6 03                        ldx     <3
00040Dr 1  85 03                        sta     <3
00040Fr 1  86 01                        stx     <1
000411r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000415r 1  00 00        
000417r 1               
000417r 1               ; TUCK ( x1 x2 -- x2 x1 x2 )
000417r 1               ;
000417r 1               ; Copy the first (top) stack item below the second stack item.
000417r 1               
000417r 1  rr rr 00 04                  HEADER  4,"TUCK",NORMAL
00041Br 1  54 55 43 4B  
00041Fr 1  20 rr rr rr  TUCK:           jsr     DO_COLON
000423r 1  rr rr rr rr  
000427r 1  rr           
000428r 1                               dw      SWAP
000428r 1                               dw      OVER
000428r 1                               dw      EXIT
000428r 1               
000428r 1               ;===============================================================================
000428r 1               ; Return Stack Operations
000428r 1               ;-------------------------------------------------------------------------------
000428r 1               
000428r 1               ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
000428r 1               ;
000428r 1               ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
000428r 1               ; SWAP >R >R.
000428r 1               
000428r 1  rr rr 00 03                  HEADER  3,"2>R",NORMAL
00042Cr 1  32 3E 52     
00042Fr 1               TWO_TO_R:
00042Fr 1  A5 03                        lda     <3                      ; Transfer x1
000431r 1  48                           pha
000432r 1  A5 01                        lda     <1                      ; Transfer x2
000434r 1  48                           pha
000435r 1  7B                           tdc
000436r 1  1A                           inc     a                       ; Clean up data stack
000437r 1  1A                           inc     a
000438r 1  1A                           inc     a
000439r 1  1A                           inc     a
00043Ar 1  5B                           tcd
00043Br 1  BB C8 C8 7C                  CONTINUE                        ; Done
00043Fr 1  00 00        
000441r 1               
000441r 1               ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
000441r 1               ;
000441r 1               ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
000441r 1               ; R> SWAP.
000441r 1               
000441r 1  rr rr 00 03                  HEADER  3,"2R>",NORMAL
000445r 1  32 52 3E     
000448r 1               TWO_R_FROM:
000448r 1  7B                           tdc
000449r 1  3A                           dec     a                       ; Make space for values
00044Ar 1  3A                           dec     a
00044Br 1  3A                           dec     a
00044Cr 1  3A                           dec     a
00044Dr 1  5B                           tcd
00044Er 1  68                           pla                             ; Transfer x2
00044Fr 1  85 01                        sta     <1
000451r 1  68                           pla                             ; Transfer x1
000452r 1  85 03                        sta     <3
000454r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000458r 1  00 00        
00045Ar 1               
00045Ar 1               ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
00045Ar 1               ;
00045Ar 1               ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
00045Ar 1               ; 2DUP >R >R SWAP.
00045Ar 1               
00045Ar 1  rr rr 00 03                  HEADER  3,"2R@",NORMAL
00045Er 1  32 52 40     
000461r 1               TWO_R_FETCH:
000461r 1  7B                           tdc
000462r 1  3A                           dec     a                       ; Make space for values
000463r 1  3A                           dec     a
000464r 1  3A                           dec     a
000465r 1  3A                           dec     a
000466r 1  5B                           tcd
000467r 1  A3 01                        lda     1,s                     ; Transfer x2
000469r 1  85 01                        sta     <1
00046Br 1  A3 03                        lda     3,s                     ; Transfer x1
00046Dr 1  85 03                        sta     <3
00046Fr 1  BB C8 C8 7C                  CONTINUE                        ; Done
000473r 1  00 00        
000475r 1               
000475r 1               ; >R ( x -- ) ( R: -- x )
000475r 1               ;
000475r 1               ; Move x to the return stack.
000475r 1               
000475r 1  rr rr 00 02                  HEADER  2,">R",NORMAL
000479r 1  3E 52        
00047Br 1               TO_R:
00047Br 1  A5 01                        lda     <1                      ; Transfer top value
00047Dr 1  48                           pha                             ; .. to return stack
00047Er 1  7B                           tdc
00047Fr 1  1A                           inc     a
000480r 1  1A                           inc     a
000481r 1  5B                           tcd
000482r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000486r 1  00 00        
000488r 1               
000488r 1               ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
000488r 1               ;
000488r 1               ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
000488r 1               ; exists if the loop control parameters are unavailable.
000488r 1               
000488r 1  rr rr 00 01                  HEADER  1,"I",NORMAL
00048Cr 1  49           
00048Dr 1               I:
00048Dr 1  7B                           tdc
00048Er 1  3A                           dec     a
00048Fr 1  3A                           dec     a
000490r 1  5B                           tcd
000491r 1  A3 01                        lda     1,s
000493r 1  85 01                        sta     <1
000495r 1  BB C8 C8 7C                  CONTINUE
000499r 1  00 00        
00049Br 1               
00049Br 1               ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
00049Br 1               ;
00049Br 1               ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
00049Br 1               ; the loop control parameters of the next-outer loop, loop-sys1, are
00049Br 1               ; unavailable.
00049Br 1               
00049Br 1  rr rr 00 01                  HEADER  1,"J",NORMAL
00049Fr 1  4A           
0004A0r 1               J:
0004A0r 1  7B                           tdc
0004A1r 1  3A                           dec     a
0004A2r 1  3A                           dec     a
0004A3r 1  5B                           tcd
0004A4r 1  A3 05                        lda     5,s
0004A6r 1  85 01                        sta     <1
0004A8r 1  BB C8 C8 7C                  CONTINUE
0004ACr 1  00 00        
0004AEr 1               
0004AEr 1               ; R> ( -- x ) ( R: x -- )
0004AEr 1               ;
0004AEr 1               ; Move x from the return stack to the data stack.
0004AEr 1               
0004AEr 1  rr rr 00 02                  HEADER  2,"R>",NORMAL
0004B2r 1  52 3E        
0004B4r 1               R_FROM:
0004B4r 1  7B                           tdc
0004B5r 1  3A                           dec     a
0004B6r 1  3A                           dec     a
0004B7r 1  5B                           tcd
0004B8r 1  68                           pla                             ; Fetch return stack value
0004B9r 1  85 01                        sta     <1
0004BBr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0004BFr 1  00 00        
0004C1r 1               
0004C1r 1               ; R@ ( -- x ) ( R: x -- x )
0004C1r 1               ;
0004C1r 1               ; Copy x from the return stack to the data stack.
0004C1r 1               
0004C1r 1  rr rr 00 02                  HEADER  2,"R@",NORMAL
0004C5r 1  52 40        
0004C7r 1               R_FETCH:
0004C7r 1  7B                           tdc
0004C8r 1  3A                           dec     a
0004C9r 1  3A                           dec     a
0004CAr 1  5B                           tcd
0004CBr 1  A3 01                        lda     1,s
0004CDr 1  85 01                        sta     <1
0004CFr 1  BB C8 C8 7C                  CONTINUE
0004D3r 1  00 00        
0004D5r 1               
0004D5r 1               ;===============================================================================
0004D5r 1               ; Single Precision Arithmetic
0004D5r 1               ;-------------------------------------------------------------------------------
0004D5r 1               
0004D5r 1               ; * ( n1|u1 n2|u2 -- n3|u3 )
0004D5r 1               ;
0004D5r 1               ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
0004D5r 1               ;
0004D5r 1               ; In this implementation it is defined as:
0004D5r 1               ;
0004D5r 1               ;   M* DROP
0004D5r 1               
0004D5r 1  rr rr 00 01                  HEADER  1,"*",NORMAL
0004D9r 1  2A           
0004DAr 1  20 rr rr rr  STAR:           jsr     DO_COLON
0004DEr 1  rr rr rr rr  
0004E2r 1  rr           
0004E3r 1                               dw      M_STAR
0004E3r 1                               dw      DROP
0004E3r 1                               dw      EXIT
0004E3r 1               
0004E3r 1               ; */ ( n1 n2 n3 -- n4 )
0004E3r 1               ;
0004E3r 1               ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
0004E3r 1               ; by n3 giving the single-cell quotient n4. An ambiguous condition exists if
0004E3r 1               ; n3 is zero or if the quotient n4 lies outside the range of a signed number.
0004E3r 1               ; If d and n3 differ in sign, the implementation-defined result returned will
0004E3r 1               ; be the same as that returned by either the phrase >R M* R> FM/MOD SWAP DROP
0004E3r 1               ; or the phrase >R M* R> SM/REM SWAP DROP.
0004E3r 1               ;
0004E3r 1               ; In this implementation it is defined as:
0004E3r 1               ;
0004E3r 1               ;   >R M* R> FM/MOD SWAP DROP
0004E3r 1               
0004E3r 1  rr rr 00 02                  HEADER  2,"*/",NORMAL
0004E7r 1  2A 2F        
0004E9r 1  20 rr rr rr  STAR_SLASH:     jsr     DO_COLON
0004EDr 1  rr rr rr rr  
0004F1r 1  rr rr rr rr  
0004FAr 1                               dw      TO_R
0004FAr 1                               dw      M_STAR
0004FAr 1                               dw      R_FROM
0004FAr 1                               dw      FM_SLASH_MOD
0004FAr 1                               dw      SWAP
0004FAr 1                               dw      DROP
0004FAr 1                               dw      EXIT
0004FAr 1               
0004FAr 1               ; */MOD ( n1 n2 n3 -- n4 n5 )
0004FAr 1               ;
0004FAr 1               ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
0004FAr 1               ; by n3 producing the single-cell remainder n4 and the single-cell quotient n5.
0004FAr 1               ; An ambiguous condition exists if n3 is zero, or if the quotient n5 lies
0004FAr 1               ; outside the range of a single-cell signed integer. If d and n3 differ in
0004FAr 1               ; sign, the implementation-defined result returned will be the same as that
0004FAr 1               ; returned by either the phrase >R M* R> FM/MOD or the phrase >R M* R> SM/REM.
0004FAr 1               ;
0004FAr 1               ; In this implementation it is defined as:
0004FAr 1               ;
0004FAr 1               ;   >R M* R> FM/MOD
0004FAr 1               
0004FAr 1  rr rr 00 05                  HEADER  5,"*/MOD",NORMAL
0004FEr 1  2A 2F 4D 4F  
000502r 1  44           
000503r 1  20 rr rr rr  STAR_SLASH_MOD: jsr     DO_COLON
000507r 1  rr rr rr rr  
00050Br 1  rr rr rr rr  
000510r 1                               dw      TO_R
000510r 1                               dw      M_STAR
000510r 1                               dw      R_FROM
000510r 1                               dw      FM_SLASH_MOD
000510r 1                               dw      EXIT
000510r 1               
000510r 1               ; + ( n1|u1 n2|u2 -- n3|u3 )
000510r 1               ;
000510r 1               ; Add n2|u2 to n1|u1, giving the sum n3|u3.
000510r 1               
000510r 1  rr rr 00 01                  HEADER  1,"+",NORMAL
000514r 1  2B           
000515r 1               PLUS:
000515r 1  18                           clc                             ; Add top two values
000516r 1  A5 03                        lda     <3
000518r 1  65 01                        adc     <1
00051Ar 1  85 03                        sta     <3                      ; Save result
00051Cr 1  7B                           tdc
00051Dr 1  1A                           inc     a                       ; Clean up data stack
00051Er 1  1A                           inc     a
00051Fr 1  5B                           tcd
000520r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000524r 1  00 00        
000526r 1               
000526r 1               ; - ( n1|u1 n2|u2 -- n3|u3 )
000526r 1               ;
000526r 1               ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
000526r 1               
000526r 1  rr rr 00 01                  HEADER  1,"-",NORMAL
00052Ar 1  2D           
00052Br 1               MINUS:
00052Br 1  38                           sec                             ; Subtract top two values
00052Cr 1  A5 03                        lda     <3
00052Er 1  E5 01                        sbc     <1
000530r 1  85 03                        sta     <3                      ; Save result
000532r 1  7B                           tdc
000533r 1  1A                           inc     a                       ; Clean up data stack
000534r 1  1A                           inc     a
000535r 1  5B                           tcd
000536r 1  BB C8 C8 7C                  CONTINUE                        ; Done
00053Ar 1  00 00        
00053Cr 1               
00053Cr 1               ; / ( n1 n2 -- n3 )
00053Cr 1               ;
00053Cr 1               ; Divide n1 by n2, giving the single-cell quotient n3. An ambiguous condition
00053Cr 1               ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
00053Cr 1               ; result returned will be the same as that returned by either the phrase >R S>D
00053Cr 1               ; R> FM/MOD SWAP DROP or the phrase >R S>D R> SM/REM SWAP DROP.
00053Cr 1               ;
00053Cr 1               ; In this implementatio it is defined as:
00053Cr 1               ;
00053Cr 1               ;   >R S>D R> FM/MOD SWAP DROP
00053Cr 1               
00053Cr 1  rr rr 00 01                  HEADER  1,"/",NORMAL
000540r 1  2F           
000541r 1  20 rr rr rr  SLASH:          jsr     DO_COLON
000545r 1  rr rr rr rr  
000549r 1  rr rr rr rr  
000552r 1                               dw      TO_R
000552r 1                               dw      S_TO_D
000552r 1                               dw      R_FROM
000552r 1                               dw      FM_SLASH_MOD
000552r 1                               dw      SWAP
000552r 1                               dw      DROP
000552r 1                               dw      EXIT
000552r 1               
000552r 1               ; /MOD ( n1 n2 -- n3 n4 )
000552r 1               ;
000552r 1               ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
000552r 1               ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
000552r 1               ; in sign, the implementation-defined result returned will be the same as that
000552r 1               ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
000552r 1               ;
000552r 1               ; In this implementation it is defined as:
000552r 1               ;
000552r 1               ;   >R S>D R> FM/MOD
000552r 1               
000552r 1  rr rr 00 04                  HEADER  4,"/MOD",NORMAL
000556r 1  2F 4D 4F 44  
00055Ar 1  20 rr rr rr  SLASH_MOD:      jsr     DO_COLON
00055Er 1  rr rr rr rr  
000562r 1  rr rr rr rr  
000567r 1                               dw      TO_R
000567r 1                               dw      S_TO_D
000567r 1                               dw      R_FROM
000567r 1                               dw      FM_SLASH_MOD
000567r 1                               dw      EXIT
000567r 1               
000567r 1               ; 1+ ( n1|u1 -- n2|u2 )
000567r 1               ;
000567r 1               ; Add one (1) to n1|u1 giving the sum n2|u2.
000567r 1               
000567r 1  rr rr 00 02                  HEADER  2,"1+",NORMAL
00056Br 1  31 2B        
00056Dr 1               ONE_PLUS:
00056Dr 1  E6 01                        inc     <1                      ; Increment top of stack
00056Fr 1  BB C8 C8 7C                  CONTINUE                        ; Done
000573r 1  00 00        
000575r 1               
000575r 1               ; 1- ( n1|u1 -- n2|u2 )
000575r 1               ;
000575r 1               ; Subtract one (1) from n1|u1 giving the difference n2|u2.
000575r 1               
000575r 1  rr rr 00 02                  HEADER  2,"1-",NORMAL
000579r 1  31 2D        
00057Br 1               ONE_MINUS:
00057Br 1  C6 01                        dec     <1                      ; Decrement top of stack
00057Dr 1  BB C8 C8 7C                  CONTINUE                        ; Done
000581r 1  00 00        
000583r 1               
000583r 1               ; 2* ( x1 -- x2 )
000583r 1               ;
000583r 1               ; x2 is the result of shifting x1 one bit toward the most-significant bit,
000583r 1               ; filling the vacated least-significant bit with zero.
000583r 1               
000583r 1  rr rr 00 02                  HEADER  2,"2*",NORMAL
000587r 1  32 2A        
000589r 1               TWO_STAR:
000589r 1  06 01                        asl     <1                      ; Multiply top value by two
00058Br 1  BB C8 C8 7C                  CONTINUE                        ; Done
00058Fr 1  00 00        
000591r 1               
000591r 1               ; 2/ ( x1 -- x2 )
000591r 1               ;
000591r 1               ; x2 is the result of shifting x1 one bit toward the least-significant bit,
000591r 1               ; leaving the most-significant bit unchanged.
000591r 1               
000591r 1  rr rr 00 02                  HEADER  2,"2/",NORMAL
000595r 1  32 2F        
000597r 1               TWO_SLASH:
000597r 1  A5 01                        lda     <1                      ; Load the top value
000599r 1  2A                           rol     a                       ; Extract the top bit
00059Ar 1  66 01                        ror     <1                      ; And shift back into value
00059Cr 1  BB C8 C8 7C                  CONTINUE
0005A0r 1  00 00        
0005A2r 1               
0005A2r 1               ; ?NEGATE ( x sign -- x/-x)
0005A2r 1               ;
0005A2r 1               ; If the sign value is negative then negate the value of x to match.
0005A2r 1               ;
0005A2r 1               ; In this implementation it is defined as:
0005A2r 1               ;
0005A2r 1               ;   0< IF NEGATE THEN
0005A2r 1               
0005A2r 1  20 rr rr rr  QUERY_NEGATE:   jsr     DO_COLON
0005A6r 1  rr rr rr rr  
0005AAr 1  rr rr rr     
0005ADr 1                               dw      ZERO_LESS
0005ADr 1                               dw      QUERY_BRANCH,QUERY_NEGATE_1
0005ADr 1                               dw      NEGATE
0005ADr 1  rr rr        QUERY_NEGATE_1: dw      EXIT
0005AFr 1               
0005AFr 1               ; ABS ( n -- u )
0005AFr 1               ;
0005AFr 1               ; u is the absolute value of n.
0005AFr 1               
0005AFr 1  rr rr 00 03                  HEADER  3,"ABS",NORMAL
0005B3r 1  41 42 53     
0005B6r 1               ABS:
0005B6r 1  A5 01                        lda     <1
0005B8r 1  10 03                        bpl     ABS_1
0005BAr 1  4C rr rr                     jmp     NEGATE
0005BDr 1  BB C8 C8 7C  ABS_1:          CONTINUE                        ; Done
0005C1r 1  00 00        
0005C3r 1               
0005C3r 1               ; FM/MOD ( n1 n2 -- n3 n4 )
0005C3r 1               ;
0005C3r 1               ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
0005C3r 1               ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
0005C3r 1               ; in sign, the implementation-defined result returned will be the same as that
0005C3r 1               ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
0005C3r 1               ;
0005C3r 1               ; In this implementation it is defined as:
0005C3r 1               ;
0005C3r 1               ;   DUP >R                      divisor
0005C3r 1               ;   2DUP XOR >R                 sign of quotient
0005C3r 1               ;   >R                          divisor
0005C3r 1               ;   DABS R@ ABS UM/MOD
0005C3r 1               ;   SWAP R> ?NEGATE SWAP        apply sign to remainder
0005C3r 1               ;   R> 0< IF                    if quotient negative,
0005C3r 1               ;       NEGATE
0005C3r 1               ;       OVER IF                 if remainder nonzero,
0005C3r 1               ;       R@ ROT - SWAP 1-        adjust rem,quot
0005C3r 1               ;       THEN
0005C3r 1               ;   THEN  R> DROP ;
0005C3r 1               
0005C3r 1  rr rr 00 06                  HEADER  6,"FM/MOD",NORMAL
0005C7r 1  46 4D 2F 4D  
0005CBr 1  4F 44        
0005CDr 1  20 rr rr rr  FM_SLASH_MOD:   jsr     DO_COLON
0005D1r 1  rr rr rr rr  
0005D5r 1  rr rr rr rr  
000606r 1                               dw      DUP
000606r 1                               dw      TO_R
000606r 1                               dw      TWO_DUP
000606r 1                               dw      XOR
000606r 1                               dw      TO_R
000606r 1                               dw      TO_R
000606r 1                               dw      DABS
000606r 1                               dw      R_FETCH
000606r 1                               dw      ABS
000606r 1                               dw      UM_SLASH_MOD
000606r 1                               dw      SWAP
000606r 1                               dw      R_FROM
000606r 1                               dw      QUERY_NEGATE
000606r 1                               dw      SWAP
000606r 1                               dw      R_FROM
000606r 1                               dw      ZERO_LESS
000606r 1                               dw      QUERY_BRANCH,FM_SLASH_MOD_1
000606r 1                               dw      NEGATE
000606r 1                               dw      OVER
000606r 1                               dw      QUERY_BRANCH,FM_SLASH_MOD_1
000606r 1                               dw      R_FETCH
000606r 1                               dw      ROT
000606r 1                               dw      MINUS
000606r 1                               dw      SWAP
000606r 1                               dw      ONE_MINUS
000606r 1  rr rr rr rr  FM_SLASH_MOD_1: dw      R_FROM
00060Ar 1  rr rr        
00060Cr 1                               dw      DROP
00060Cr 1                               dw      EXIT
00060Cr 1               
00060Cr 1               ; MAX ( n1 n2 -- n3 )
00060Cr 1               ;
00060Cr 1               ; n3 is the greater of n1 and n2.
00060Cr 1               
00060Cr 1  rr rr 00 03                  HEADER  3,"MAX",NORMAL
000610r 1  4D 41 58     
000613r 1  20 rr rr rr  MAX:            jsr     DO_COLON
000617r 1  rr rr rr rr  
00061Br 1  rr rr rr rr  
000620r 1                               dw      TWO_DUP
000620r 1                               dw      LESS
000620r 1                               dw      QUERY_BRANCH,MAX_1
000620r 1                               dw      SWAP
000620r 1  rr rr rr rr  MAX_1:          dw      DROP
000624r 1                               dw      EXIT
000624r 1               
000624r 1               ; MIN ( n1 n2 -- n3 )
000624r 1               ;
000624r 1               ; n3 is the lesser of n1 and n2.
000624r 1               
000624r 1  rr rr 00 03                  HEADER  3,"MIN",NORMAL
000628r 1  4D 49 4E     
00062Br 1  20 rr rr rr  MIN:            jsr     DO_COLON
00062Fr 1  rr rr rr rr  
000633r 1  rr rr rr rr  
000638r 1                               dw      TWO_DUP
000638r 1                               dw      GREATER
000638r 1                               dw      QUERY_BRANCH,MIN_1
000638r 1                               dw      SWAP
000638r 1  rr rr rr rr  MIN_1:          dw      DROP
00063Cr 1                               dw      EXIT
00063Cr 1               
00063Cr 1               ; MOD ( n1 n2 -- n3 )
00063Cr 1               ;
00063Cr 1               ; Divide n1 by n2, giving the single-cell remainder n3. An ambiguous condition
00063Cr 1               ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
00063Cr 1               ; result returned will be the same as that returned by either the phrase >R S>D
00063Cr 1               ; R> FM/MOD DROP or the phrase >R S>D R> SM/REM DROP.
00063Cr 1               ;
00063Cr 1               ; In this implementation it is defined as:
00063Cr 1               ;
00063Cr 1               ;   >R S>D R> FM/MOD DROP
00063Cr 1               
00063Cr 1  rr rr 00 03                  HEADER  3,"MOD",NORMAL
000640r 1  4D 4F 44     
000643r 1  20 rr rr rr  MOD:            jsr     DO_COLON
000647r 1  rr rr rr rr  
00064Br 1  rr rr rr rr  
000652r 1                               dw      TO_R
000652r 1                               dw      S_TO_D
000652r 1                               dw      R_FROM
000652r 1                               dw      FM_SLASH_MOD
000652r 1                               dw      DROP
000652r 1                               dw      EXIT
000652r 1               
000652r 1               ; NEGATE ( n1 -- n2 )
000652r 1               ;
000652r 1               ; Negate n1, giving its arithmetic inverse n2.
000652r 1               
000652r 1  rr rr 00 06                  HEADER  6,"NEGATE",NORMAL
000656r 1  4E 45 47 41  
00065Ar 1  54 45        
00065Cr 1               NEGATE:
00065Cr 1  38                           sec                             ; Negate the top of stack
00065Dr 1  A9 00 00                     lda     #0
000660r 1  E5 01                        sbc     <1
000662r 1  85 01                        sta     <1
000664r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000668r 1  00 00        
00066Ar 1               
00066Ar 1               ; UMAX ( x1 x2 -- x3 )
00066Ar 1               ;
00066Ar 1               ; x3 is the greater of x1 and x2.
00066Ar 1               
00066Ar 1  rr rr 00 04                  HEADER  4,"UMAX",NORMAL
00066Er 1  55 4D 41 58  
000672r 1               UMAX:
000672r 1  A5 01                        lda     <1                      ; Compare the top values
000674r 1  C5 03                        cmp     <3
000676r 1  B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
000678r 1  4C rr rr                     jmp     DROP                    ; No, x1 is
00067Br 1  4C rr rr     UMAX_EXIT:      jmp     NIP
00067Er 1               
00067Er 1               ; UMIN ( x1 x2 -- x3 )
00067Er 1               ;
00067Er 1               ; x3 is the lesser of x1 and x2.
00067Er 1               
00067Er 1  rr rr 00 04                  HEADER  4,"UMIN",NORMAL
000682r 1  55 4D 49 4E  
000686r 1               UMIN:
000686r 1  A5 01                        lda     <1                      ; Compare the top values
000688r 1  C5 03                        cmp     <3
00068Ar 1  90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
00068Cr 1  4C rr rr                     jmp     DROP                    ; No, x1 is
00068Fr 1  4C rr rr     UMIN_EXIT:      jmp     NIP
000692r 1               
000692r 1               ;===============================================================================
000692r 1               ; Double Precision Arithmetic
000692r 1               ;-------------------------------------------------------------------------------
000692r 1               
000692r 1               ; ?DNEGATE ( d1 sign -- d1/-d1 )
000692r 1               ;
000692r 1               ; If sign is less than zero than negate d1 otherwise leave it unchanged.
000692r 1               
000692r 1  20 rr rr rr  QUERY_DNEGATE:  jsr     DO_COLON
000696r 1  rr rr rr rr  
00069Ar 1  rr rr rr     
00069Dr 1                               dw      ZERO_LESS
00069Dr 1                               dw      QUERY_BRANCH,QUERY_DNEG_1
00069Dr 1                               dw      DNEGATE
00069Dr 1  rr rr        QUERY_DNEG_1:   dw      EXIT
00069Fr 1               
00069Fr 1               ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
00069Fr 1               ;
00069Fr 1               ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
00069Fr 1               
00069Fr 1  rr rr 00 02                  HEADER  2,"D+",NORMAL
0006A3r 1  44 2B        
0006A5r 1               D_PLUS:
0006A5r 1  18                           clc
0006A6r 1  A5 07                        lda     <7                      ; Add low words
0006A8r 1  65 03                        adc     <3
0006AAr 1  85 07                        sta     <7
0006ACr 1  A5 05                        lda     <5                      ; Then the high words
0006AEr 1  65 01                        adc     <1
0006B0r 1  85 05                        sta     <5
0006B2r 1  7B                           tdc                             ; Drop top double
0006B3r 1  1A                           inc     a
0006B4r 1  1A                           inc     a
0006B5r 1  1A                           inc     a
0006B6r 1  1A                           inc     a
0006B7r 1  5B                           tcd
0006B8r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0006BCr 1  00 00        
0006BEr 1               
0006BEr 1               ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
0006BEr 1               ;
0006BEr 1               ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
0006BEr 1               
0006BEr 1  rr rr 00 02                  HEADER  2,"D-",NORMAL
0006C2r 1  44 2D        
0006C4r 1               D_MINUS:
0006C4r 1  38                           sec
0006C5r 1  A5 07                        lda     <7                      ; Subtract low words
0006C7r 1  E5 03                        sbc     <3
0006C9r 1  85 07                        sta     <7
0006CBr 1  A5 05                        lda     <5                      ; Then the high words
0006CDr 1  E5 01                        sbc     <1
0006CFr 1  85 05                        sta     <5
0006D1r 1  7B                           tdc                             ; Drop top double
0006D2r 1  1A                           inc     a
0006D3r 1  1A                           inc     a
0006D4r 1  1A                           inc     a
0006D5r 1  1A                           inc     a
0006D6r 1  5B                           tcd
0006D7r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0006DBr 1  00 00        
0006DDr 1               
0006DDr 1               ; D0< ( d -- flag )
0006DDr 1               ;
0006DDr 1               ; flag is true if and only if d is less than zero.
0006DDr 1               
0006DDr 1  rr rr 00 03                  HEADER  3,"D0<",NORMAL
0006E1r 1  44 30 3C     
0006E4r 1               D_ZERO_LESS:
0006E4r 1  A6 01                        ldx     <1                      ; Fetch sign
0006E6r 1  7B                           tdc                             ; Drop a word
0006E7r 1  1A                           inc     a
0006E8r 1  1A                           inc     a
0006E9r 1  5B                           tcd
0006EAr 1  64 01                        stz     <1                      ; Assume false
0006ECr 1  8A                           txa
0006EDr 1  10 02                        bpl     D_ZERO_LESS_1
0006EFr 1  C6 01                        dec     <1
0006F1r 1  BB C8 C8 7C  D_ZERO_LESS_1:  CONTINUE
0006F5r 1  00 00        
0006F7r 1               
0006F7r 1               ; D0= ( d -- flag )
0006F7r 1               ;
0006F7r 1               ; flag is true if and only if d is equal to zero.
0006F7r 1               
0006F7r 1  rr rr 00 03                  HEADER  3,"D0=",NORMAL
0006FBr 1  44 30 3D     
0006FEr 1               D_ZERO_EQUAL:
0006FEr 1  A6 01                        ldx     <1                      ; Fetch sign
000700r 1  7B                           tdc                             ; Drop a word
000701r 1  1A                           inc     a
000702r 1  1A                           inc     a
000703r 1  5B                           tcd
000704r 1  64 01                        stz     <1                      ; Assume false
000706r 1  8A                           txa
000707r 1  D0 02                        bne     D_ZERO_EQUAL_1
000709r 1  C6 01                        dec     <1
00070Br 1  BB C8 C8 7C  D_ZERO_EQUAL_1: CONTINUE
00070Fr 1  00 00        
000711r 1               
000711r 1               ; D2* ( xd1 -- xd2 )
000711r 1               ;
000711r 1               ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
000711r 1               ; filling the vacated least-significant bit with zero.
000711r 1               
000711r 1  rr rr 00 03                  HEADER  3,"D2*",NORMAL
000715r 1  44 32 2A     
000718r 1               D_TWO_STAR:
000718r 1  06 03                        asl     <3
00071Ar 1  26 01                        rol     <1
00071Cr 1  BB C8 C8 7C                  CONTINUE
000720r 1  00 00        
000722r 1               
000722r 1               ; D2/ ( xd1 -- xd2 )
000722r 1               ;
000722r 1               ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
000722r 1               ; leaving the most-significant bit unchanged.
000722r 1               
000722r 1  rr rr 00 03                  HEADER  3,"D2/",NORMAL
000726r 1  44 32 2F     
000729r 1               D_TWO_SLASH:
000729r 1  A5 01                        lda     <1
00072Br 1  2A                           rol     a
00072Cr 1  66 01                        ror     <1
00072Er 1  66 03                        ror     <3
000730r 1  BB C8 C8 7C                  CONTINUE
000734r 1  00 00        
000736r 1               
000736r 1               ; D< ( d1 d2 -- flag )
000736r 1               ;
000736r 1               ; flag is true if and only if d1 is less than d2.
000736r 1               
000736r 1  rr rr 00 02                  HEADER  2,"D<",NORMAL
00073Ar 1  44 3C        
00073Cr 1  20 rr rr rr  D_LESS:         jsr     DO_COLON
000740r 1  rr rr rr rr  
000744r 1  rr           
000745r 1                               dw      D_MINUS
000745r 1                               dw      D_ZERO_LESS
000745r 1                               dw      EXIT
000745r 1               
000745r 1               ; D= ( d1 d2 -- flag )
000745r 1               ;
000745r 1               ; flag is true if and only if d1 is bit-for-bit the same as d2.
000745r 1               
000745r 1  rr rr 00 02                  HEADER  2,"D=",NORMAL
000749r 1  44 3D        
00074Br 1  20 rr rr rr  D_EQUAL:        jsr     DO_COLON
00074Fr 1  rr rr rr rr  
000753r 1  rr           
000754r 1                               dw      D_MINUS
000754r 1                               dw      D_ZERO_EQUAL
000754r 1                               dw      EXIT
000754r 1               
000754r 1               ; DABS ( d -- ud )
000754r 1               ;
000754r 1               ; ud is the absolute value of d.
000754r 1               
000754r 1  rr rr 00 04                  HEADER  4,"DABS",NORMAL
000758r 1  44 41 42 53  
00075Cr 1               DABS:
00075Cr 1  A5 01                        lda     <1
00075Er 1  10 03                        bpl     DABS_1
000760r 1  4C rr rr                     jmp     DNEGATE
000763r 1  BB C8 C8 7C  DABS_1:         CONTINUE
000767r 1  00 00        
000769r 1               
000769r 1               ; DMAX ( d1 d2 -- d3 )
000769r 1               ;
000769r 1               ; d3 is the greater of d1 and d2.
000769r 1               
000769r 1  rr rr 00 04                  HEADER  4,"DMAX",NORMAL
00076Dr 1  44 4D 41 58  
000771r 1  20 rr rr rr  DMAX:           jsr     DO_COLON
000775r 1  rr rr rr rr  
000779r 1  rr rr rr rr  
000780r 1                               dw      TWO_OVER
000780r 1                               dw      TWO_OVER
000780r 1                               dw      D_LESS
000780r 1                               dw      QUERY_BRANCH,DMAX_1
000780r 1                               dw      TWO_SWAP
000780r 1  rr rr rr rr  DMAX_1:         dw      TWO_DROP
000784r 1                               dw      EXIT
000784r 1               
000784r 1               ; DMIN ( d1 d2 -- d3 )
000784r 1               ;
000784r 1               ; d3 is the lesser of d1 and d2.
000784r 1               
000784r 1  rr rr 00 04                  HEADER  4,"DMIN",NORMAL
000788r 1  44 4D 49 4E  
00078Cr 1  20 rr rr rr  DMIN:           jsr     DO_COLON
000790r 1  rr rr rr rr  
000794r 1  rr rr rr rr  
00079Dr 1                               dw      TWO_OVER
00079Dr 1                               dw      TWO_OVER
00079Dr 1                               dw      D_LESS
00079Dr 1                               dw      INVERT
00079Dr 1                               dw      QUERY_BRANCH,DMIN_1
00079Dr 1                               dw      TWO_SWAP
00079Dr 1  rr rr rr rr  DMIN_1:         dw      TWO_DROP
0007A1r 1                               dw      EXIT
0007A1r 1               
0007A1r 1               ; DNEGATE ( d1 -- d2 )
0007A1r 1               ;
0007A1r 1               ; d2 is the negation of d1.
0007A1r 1               
0007A1r 1  rr rr 00 07                  HEADER  7,"DNEGATE",NORMAL
0007A5r 1  44 4E 45 47  
0007A9r 1  41 54 45     
0007ACr 1               DNEGATE:
0007ACr 1  38                           sec
0007ADr 1  A9 00 00                     lda     #0                      ; Subtract low word from zero
0007B0r 1  E5 03                        sbc     <3
0007B2r 1  85 03                        sta     <3
0007B4r 1  A9 00 00                     lda     #0                      ; Then the high word
0007B7r 1  E5 01                        sbc     <1
0007B9r 1  85 01                        sta     <1
0007BBr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0007BFr 1  00 00        
0007C1r 1               
0007C1r 1               ;===============================================================================
0007C1r 1               ; Mixed Arithmetic
0007C1r 1               ;-------------------------------------------------------------------------------
0007C1r 1               
0007C1r 1               ; D>S ( d -- n )
0007C1r 1               ;
0007C1r 1               ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
0007C1r 1               ; range of a signed single-cell number.
0007C1r 1               
0007C1r 1  rr rr 00 03                  HEADER  3,"D>S",NORMAL
0007C5r 1  44 3E 53     
0007C8r 1               D_TO_S:
0007C8r 1  7B                           tdc
0007C9r 1  1A                           inc     a                       ; Drop the high word
0007CAr 1  1A                           inc     a
0007CBr 1  5B                           tcd
0007CCr 1  BB C8 C8 7C                  CONTINUE
0007D0r 1  00 00        
0007D2r 1               
0007D2r 1               ; M* ( n1 n2 -- d )
0007D2r 1               ;
0007D2r 1               ; d is the signed product of n1 times n2.
0007D2r 1               ;
0007D2r 1               ; In this implementation it is defined as:
0007D2r 1               ;
0007D2r 1               ;   2DUP XOR >R                 carries sign of the result
0007D2r 1               ;   SWAP ABS SWAP ABS UM*
0007D2r 1               ;   R> ?DNEGATE
0007D2r 1               
0007D2r 1  rr rr 00 02                  HEADER  2,"M*",NORMAL
0007D6r 1  4D 2A        
0007D8r 1  20 rr rr rr  M_STAR:         jsr     DO_COLON
0007DCr 1  rr rr rr rr  
0007E0r 1  rr rr rr rr  
0007F1r 1                               dw      TWO_DUP
0007F1r 1                               dw      XOR
0007F1r 1                               dw      TO_R
0007F1r 1                               dw      SWAP
0007F1r 1                               dw      ABS
0007F1r 1                               dw      SWAP
0007F1r 1                               dw      ABS
0007F1r 1                               dw      UM_STAR
0007F1r 1                               dw      R_FROM
0007F1r 1                               dw      QUERY_DNEGATE
0007F1r 1                               dw      EXIT
0007F1r 1               
0007F1r 1               ; M*/ ( d1 n1 +n2 -- d2 )
0007F1r 1               ;
0007F1r 1               ; Multiply d1 by n1 producing the triple-cell intermediate result t. Divide t
0007F1r 1               ; by +n2 giving the double-cell quotient d2. An ambiguous condition exists if
0007F1r 1               ; +n2 is zero or negative, or the quotient lies outside of the range of a
0007F1r 1               ; double-precision signed integer.
0007F1r 1               
0007F1r 1               
0007F1r 1               
0007F1r 1               ; M+ ( d1|ud1 n -- d2|ud2 )
0007F1r 1               ;
0007F1r 1               ; Add n to d1|ud1, giving the sum d2|ud2.
0007F1r 1               
0007F1r 1  rr rr 00 02                  HEADER  2,"M+",NORMAL
0007F5r 1  4D 2B        
0007F7r 1               M_PLUS:
0007F7r 1  18                           clc
0007F8r 1  A5 01                        lda     <1
0007FAr 1  65 05                        adc     <5
0007FCr 1  85 05                        sta     <5
0007FEr 1  90 02                        bcc     $+4
000800r 1  E6 03                        inc     <3
000802r 1  7B                           tdc
000803r 1  1A                           inc     a
000804r 1  1A                           inc     a
000805r 1  5B                           tcd
000806r 1  BB C8 C8 7C                  CONTINUE
00080Ar 1  00 00        
00080Cr 1               
00080Cr 1               ; S>D ( n -- d )
00080Cr 1               ;
00080Cr 1               ; Convert the number n to the double-cell number d with the same numerical
00080Cr 1               ; value.
00080Cr 1               
00080Cr 1  rr rr 00 03                  HEADER  3,"S>D",NORMAL
000810r 1  53 3E 44     
000813r 1               S_TO_D:
000813r 1  7B                           tdc
000814r 1  3A                           dec     a                       ; Assume n is positive
000815r 1  3A                           dec     a
000816r 1  5B                           tcd
000817r 1  64 01                        stz     <1                      ; .. push a zero value
000819r 1  A5 03                        lda     <3                      ; Test the number
00081Br 1  10 02                        bpl     S_TO_D_1
00081Dr 1  C6 01                        dec     <1                      ; Make top -1 if negative
00081Fr 1  BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
000823r 1  00 00        
000825r 1               
000825r 1               ; SM/REM ( d1 n1 -- n2 n3 )
000825r 1               ;
000825r 1               ; Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
000825r 1               ; Input and output stack arguments are signed. An ambiguous condition exists if
000825r 1               ; n1 is zero or if the quotient lies outside the range of a single-cell signed
000825r 1               ; integer.
000825r 1               ;
000825r 1               ; In this implementation it is defined as:
000825r 1               ;
000825r 1               ;   2DUP XOR >R                 sign of quotient
000825r 1               ;   OVER >R                     sign of remainder
000825r 1               ;   ABS >R DABS R> UM/MOD
000825r 1               ;   SWAP R> ?NEGATE
000825r 1               ;   SWAP R> ?NEGATE ;
000825r 1               
000825r 1  rr rr 00 06                  HEADER  6,"SM/REM",NORMAL
000829r 1  53 4D 2F 52  
00082Dr 1  45 4D        
00082Fr 1  20 rr rr rr  SM_SLASH_REM:   jsr     DO_COLON
000833r 1  rr rr rr rr  
000837r 1  rr rr rr rr  
000854r 1                               dw      TWO_DUP
000854r 1                               dw      XOR
000854r 1                               dw      TO_R
000854r 1                               dw      OVER
000854r 1                               dw      TO_R
000854r 1                               dw      ABS
000854r 1                               dw      TO_R
000854r 1                               dw      DABS
000854r 1                               dw      R_FROM
000854r 1                               dw      UM_SLASH_MOD
000854r 1                               dw      SWAP
000854r 1                               dw      R_FROM
000854r 1                               dw      QUERY_NEGATE
000854r 1                               dw      SWAP
000854r 1                               dw      R_FROM
000854r 1                               dw      QUERY_NEGATE
000854r 1                               dw      EXIT
000854r 1               
000854r 1               ; UD* ( ud1 d2 -- ud3)
000854r 1               ;
000854r 1               ; 32*16->32 multiply
000854r 1               ;
000854r 1               ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
000854r 1               
000854r 1  rr rr 00 03                  HEADER  3,"UD*",NORMAL
000858r 1  55 44 2A     
00085Br 1  20 rr rr rr  UD_STAR:        jsr     DO_COLON
00085Fr 1  rr rr rr rr  
000863r 1  rr rr rr rr  
000872r 1                               dw      DUP
000872r 1                               dw      TO_R
000872r 1                               dw      UM_STAR
000872r 1                               dw      DROP
000872r 1                               dw      SWAP
000872r 1                               dw      R_FROM
000872r 1                               dw      UM_STAR
000872r 1                               dw      ROT
000872r 1                               dw      PLUS
000872r 1                               dw      EXIT
000872r 1               
000872r 1               ; UM* ( u1 u2 -- ud )
000872r 1               ;
000872r 1               ; Multiply u1 by u2, giving the unsigned double-cell product ud. All values and
000872r 1               ; arithmetic are unsigned.
000872r 1               
000872r 1  rr rr 00 03                  HEADER  3,"UM*",NORMAL
000876r 1  55 4D 2A     
000879r 1               UM_STAR:
000879r 1  A5 01                        lda     <1                      ; Fetch multiplier
00087Br 1  48                           pha
00087Cr 1  64 01                        stz     <1                      ; Clear the result
00087Er 1  A2 10 00                     ldx     #16
000881r 1  A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
000883r 1  4A                           lsr     a
000884r 1  90 07                        bcc     UM_STAR_2               ; Not set, no add
000886r 1  A3 01                        lda     1,s                     ; Fetch multiplicand
000888r 1  18                           clc
000889r 1  65 01                        adc     <1
00088Br 1  85 01                        sta     <1
00088Dr 1  66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
00088Fr 1  66 03                        ror     <3
000891r 1  CA                           dex
000892r 1  D0 ED                        bne     UM_STAR_1
000894r 1  68                           pla
000895r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000899r 1  00 00        
00089Br 1               
00089Br 1               ; UM/MOD ( ud u1 -- u2 u3 )
00089Br 1               ;
00089Br 1               ; Divide ud by u1, giving the quotient u3 and the remainder u2. All values and
00089Br 1               ; arithmetic are unsigned. An ambiguous condition exists if u1 is zero or if the
00089Br 1               ; quotient lies outside the range of a single-cell unsigned integer.
00089Br 1               
00089Br 1  rr rr 00 06                  HEADER  6,"UM/MOD",NORMAL
00089Fr 1  55 4D 2F 4D  
0008A3r 1  4F 44        
0008A5r 1               UM_SLASH_MOD:
0008A5r 1  38                           sec                             ; Check for overflow
0008A6r 1  A5 03                        lda     <3
0008A8r 1  E5 01                        sbc     <1
0008AAr 1  B0 1A                        bcs     UM_SLASH_MOD_3
0008ACr 1               
0008ACr 1  A2 11 00                     ldx     #17
0008AFr 1  26 05        UM_SLASH_MOD_1: rol     <5                      ; Rotate dividend lo
0008B1r 1  CA                           dex
0008B2r 1  F0 19                        beq     UM_SLASH_MOD_4
0008B4r 1  26 03                        rol     <3
0008B6r 1  B0 06                        bcs     UM_SLASH_MOD_2          ; Carry set dividend > divisor
0008B8r 1               
0008B8r 1  A5 03                        lda     <3                      ; Is dividend < divisor?
0008BAr 1  C5 01                        cmp     <1
0008BCr 1  90 F1                        bcc     UM_SLASH_MOD_1          ; Yes, shift in 0
0008BEr 1               
0008BEr 1  A5 03        UM_SLASH_MOD_2: lda     <3                      ; Reduce dividend
0008C0r 1  E5 01                        sbc     <1
0008C2r 1  85 03                        sta     <3
0008C4r 1  80 E9                        bra     UM_SLASH_MOD_1          ; Shift in 1
0008C6r 1               
0008C6r 1  A9 FF FF     UM_SLASH_MOD_3: lda     #$ffff                  ; Overflowed set results
0008C9r 1  85 03                        sta     <3
0008CBr 1  85 05                        sta     <5
0008CDr 1  7B           UM_SLASH_MOD_4: tdc                             ; Drop top word
0008CEr 1  1A                           inc     a
0008CFr 1  1A                           inc     a
0008D0r 1  5B                           tcd
0008D1r 1  4C rr rr                     jmp     SWAP                    ; Swap quotient and remainder
0008D4r 1               
0008D4r 1               ;===============================================================================
0008D4r 1               ; Comparisons
0008D4r 1               ;-------------------------------------------------------------------------------
0008D4r 1               
0008D4r 1               ; 0< ( n -- flag )
0008D4r 1               ;
0008D4r 1               ; flag is true if and only if n is less than zero.
0008D4r 1               
0008D4r 1  rr rr 00 02                  HEADER  2,"0<",NORMAL
0008D8r 1  30 3C        
0008DAr 1               ZERO_LESS:
0008DAr 1  A5 01                        lda     <1                      ; Test top of stack
0008DCr 1  64 01                        stz     <1                      ; Assume false result
0008DEr 1  10 02                        bpl     ZERO_LT_1               ; Was the value negative?
0008E0r 1  C6 01                        dec     <1                      ; Yes, make true result
0008E2r 1  BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
0008E6r 1  00 00        
0008E8r 1               
0008E8r 1               ; 0<> ( x -- flag )
0008E8r 1               ;
0008E8r 1               ; flag is true if and only if x is not equal to zero.
0008E8r 1               
0008E8r 1  rr rr 00 03                  HEADER  3,"0<>",NORMAL
0008ECr 1  30 3C 3E     
0008EFr 1               ZERO_NOT_EQUAL:
0008EFr 1  A5 01                        lda     <1                      ; Test top of stack
0008F1r 1  64 01                        stz     <1                      ; Assume false result
0008F3r 1  F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
0008F5r 1  C6 01                        dec     <1                      ; Yes, make true result
0008F7r 1  BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
0008FBr 1  00 00        
0008FDr 1               
0008FDr 1               ; 0= ( x -- flag )
0008FDr 1               ;
0008FDr 1               ; flag is true if and only if x is equal to zero.
0008FDr 1               
0008FDr 1  rr rr 00 02                  HEADER  2,"0=",NORMAL
000901r 1  30 3D        
000903r 1               ZERO_EQUAL:
000903r 1  A5 01                        lda     <1                      ; Test top of stack
000905r 1  64 01                        stz     <1                      ; Assume false result
000907r 1  D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
000909r 1  C6 01                        dec     <1                      ; Yes, make true result
00090Br 1  BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
00090Fr 1  00 00        
000911r 1               
000911r 1               ; 0> ( n -- flag )
000911r 1               ;
000911r 1               ; flag is true if and only if n is greater than zero.
000911r 1               
000911r 1  rr rr 00 02                  HEADER  2,"0>",NORMAL
000915r 1  30 3E        
000917r 1               ZERO_GREATER:
000917r 1  A5 01                        lda     <1                      ; Test top of stack
000919r 1  64 01                        stz     <1                      ; Assume false result
00091Br 1  30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
00091Dr 1  F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
00091Fr 1  C6 01                        dec     <1                      ; Yes, make true result
000921r 1  BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
000925r 1  00 00        
000927r 1               
000927r 1               ; < ( n1 n2 -- flag )
000927r 1               ;
000927r 1               ; flag is true if and only if n1 is less than n2.
000927r 1               
000927r 1  rr rr 00 01                  HEADER  1,"<",NORMAL
00092Br 1  3C           
00092Cr 1  20 rr rr rr  LESS:           jsr     DO_COLON
000930r 1  rr rr rr rr  
000934r 1  rr           
000935r 1                               dw      SWAP
000935r 1                               dw      GREATER
000935r 1                               dw      EXIT
000935r 1               
000935r 1               ; <> ( x1 x2 -- flag )
000935r 1               ;
000935r 1               ; flag is true if and only if x1 is not bit-for-bit the same as x2.
000935r 1               
000935r 1  rr rr 00 02                  HEADER  2,"<>",NORMAL
000939r 1  3C 3E        
00093Br 1               NOT_EQUAL:
00093Br 1  A6 01                        ldx     <1                      ; Pull x2 from stack
00093Dr 1  7B                           tdc
00093Er 1  1A                           inc     a
00093Fr 1  1A                           inc     a
000940r 1  5B                           tcd
000941r 1  E4 01                        cpx     <1                      ; Compare with x1
000943r 1  64 01                        stz     <1                      ; Assume equal
000945r 1  F0 02                        beq     NE_EXIT                 ; Test flags
000947r 1  C6 01                        dec     <1                      ; Make result true
000949r 1  BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
00094Dr 1  00 00        
00094Fr 1               
00094Fr 1               ; = ( x1 x2 -- flag )
00094Fr 1               ;
00094Fr 1               ; flag is true if and only if x1 is bit-for-bit the same as x2.
00094Fr 1               
00094Fr 1  rr rr 00 01                  HEADER  1,"=",NORMAL
000953r 1  3D           
000954r 1               EQUAL:
000954r 1  A6 01                        ldx     <1                      ; Pull x2 from stack
000956r 1  7B                           tdc
000957r 1  1A                           inc     a
000958r 1  1A                           inc     a
000959r 1  5B                           tcd
00095Ar 1  E4 01                        cpx     <1                      ; Compare with x1
00095Cr 1  64 01                        stz     <1                      ; Assume not equal
00095Er 1  D0 02                        bne     EQ_EXIT                 ; Test the flags
000960r 1  C6 01                        dec     <1                      ; Make result true
000962r 1  BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
000966r 1  00 00        
000968r 1               
000968r 1               ; > ( n1 n2 -- flag )
000968r 1               ;
000968r 1               ; flag is true if and only if n1 is greater than n2.
000968r 1               
000968r 1  rr rr 00 01                  HEADER  1,">",NORMAL
00096Cr 1  3E           
00096Dr 1               GREATER:
00096Dr 1  A6 01                        ldx     <1                      ; Pull x2 from stack
00096Fr 1  7B                           tdc
000970r 1  1A                           inc     a
000971r 1  1A                           inc     a
000972r 1  5B                           tcd
000973r 1  8A                           txa
000974r 1  38                           sec                             ; Compare with x1
000975r 1  E5 01                        sbc     <1
000977r 1  64 01                        stz     <1                      ; Assume false result
000979r 1  50 03                        bvc     GREATER_1
00097Br 1  49 00 80                     eor     #$8000
00097Er 1  10 02        GREATER_1:      bpl     GREATER_2               ; V == 1 && N == 1
000980r 1  C6 01                        dec     <1
000982r 1  BB C8 C8 7C  GREATER_2:      CONTINUE
000986r 1  00 00        
000988r 1               
000988r 1               ; U< ( u1 u2 -- flag )
000988r 1               ;
000988r 1               ; flag is true if and only if u1 is less than u2.
000988r 1               
000988r 1  rr rr 00 02                  HEADER  2,"U<",NORMAL
00098Cr 1  55 3C        
00098Er 1               U_LESS:
00098Er 1  A6 01                        ldx     <1                      ; Pull x2
000990r 1  7B                           tdc                             ; Drop from stack
000991r 1  1A                           inc     a
000992r 1  1A                           inc     a
000993r 1  5B                           tcd
000994r 1  E4 01                        cpx     <1                      ; Compare with x1
000996r 1  64 01                        stz     <1                      ; Assume false
000998r 1  F0 04                        beq     U_LESS_1                ; Equal
00099Ar 1  90 02                        bcc     U_LESS_1                ; Less
00099Cr 1  C6 01                        dec     <1
00099Er 1  BB C8 C8 7C  U_LESS_1:       CONTINUE
0009A2r 1  00 00        
0009A4r 1               
0009A4r 1               ; U> ( u1 u2 -- flag )
0009A4r 1               ;
0009A4r 1               ; flag is true if and only if u1 is greater than u2.
0009A4r 1               
0009A4r 1  rr rr 00 02                  HEADER  2,"U>",NORMAL
0009A8r 1  55 3E        
0009AAr 1  20 rr rr rr  U_GREATER:      jsr     DO_COLON
0009AEr 1  rr rr rr rr  
0009B2r 1  rr           
0009B3r 1                               dw      SWAP
0009B3r 1                               dw      U_LESS
0009B3r 1                               dw      EXIT
0009B3r 1               
0009B3r 1               ;===============================================================================
0009B3r 1               ; Logical Operations
0009B3r 1               ;-------------------------------------------------------------------------------
0009B3r 1               
0009B3r 1               ; AND ( x1 x2 -- x3 )
0009B3r 1               ;
0009B3r 1               ; x3 is the bit-by-bit logical and of x1 with x2.
0009B3r 1               
0009B3r 1  rr rr 00 03                  HEADER  3,"AND",NORMAL
0009B7r 1  41 4E 44     
0009BAr 1               _AND:
0009BAr 1  A5 01                        lda     <1
0009BCr 1  25 03                        and     <3
0009BEr 1  85 03                        sta     <3
0009C0r 1  7B                           tdc
0009C1r 1  1A                           inc     a
0009C2r 1  1A                           inc     a
0009C3r 1  5B                           tcd
0009C4r 1  BB C8 C8 7C                  CONTINUE
0009C8r 1  00 00        
0009CAr 1               
0009CAr 1               ; INVERT ( x1 -- x2 )
0009CAr 1               ;
0009CAr 1               ; Invert all bits of x1, giving its logical inverse x2.
0009CAr 1               
0009CAr 1  rr rr 00 06                  HEADER  6,"INVERT",NORMAL
0009CEr 1  49 4E 56 45  
0009D2r 1  52 54        
0009D4r 1               INVERT:
0009D4r 1  A5 01                        lda     <1                      ; Fetch top value
0009D6r 1  49 FF FF                     eor     #$ffff                  ; Invert all the bits
0009D9r 1  85 01                        sta     <1                      ; .. and write back
0009DBr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0009DFr 1  00 00        
0009E1r 1               
0009E1r 1               ; LSHIFT ( x1 u -- x2 )
0009E1r 1               ;
0009E1r 1               ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
0009E1r 1               ; into the least significant bits vacated by the shift. An ambiguous condition
0009E1r 1               ; exists if u is greater than or equal to the number of bits in a cell.
0009E1r 1               
0009E1r 1  rr rr 00 06                  HEADER  6,"LSHIFT",NORMAL
0009E5r 1  4C 53 48 49  
0009E9r 1  46 54        
0009EBr 1               LSHIFT:
0009EBr 1  A6 01                        ldx     <1                      ; Pull bit count
0009EDr 1  08                           php
0009EEr 1  7B                           tdc
0009EFr 1  1A                           inc     a                       ; .. from the stack
0009F0r 1  1A                           inc     a
0009F1r 1  5B                           tcd
0009F2r 1  28                           plp
0009F3r 1  F0 0A                        beq     LSHIFT_0                ; Zero shift?
0009F5r 1  E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
0009F8r 1  B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
0009FAr 1  06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
0009FCr 1  CA                           dex                             ; Update count
0009FDr 1  D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
0009FFr 1  BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
000A03r 1  00 00        
000A05r 1  64 01        LSHIFT_2        stz     <1                      ; Clear top value
000A07r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000A0Br 1  00 00        
000A0Dr 1               
000A0Dr 1               ; OR ( x1 x2 -- x3 )
000A0Dr 1               ;
000A0Dr 1               ; x3 is the bit-by-bit inclusive-or of x1 with x2.
000A0Dr 1               
000A0Dr 1  rr rr 00 02                  HEADER  2,"OR",NORMAL
000A11r 1  4F 52        
000A13r 1               OR:
000A13r 1  A5 01                        lda     <1
000A15r 1  05 03                        ora     <3
000A17r 1  85 03                        sta     <3
000A19r 1  7B                           tdc
000A1Ar 1  1A                           inc     a
000A1Br 1  1A                           inc     a
000A1Cr 1  5B                           tcd
000A1Dr 1  BB C8 C8 7C                  CONTINUE
000A21r 1  00 00        
000A23r 1               
000A23r 1               ; RSHIFT ( x1 u -- x2 )
000A23r 1               ;
000A23r 1               ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
000A23r 1               ; into the most significant bits vacated by the shift. An ambiguous condition
000A23r 1               ; exists if u is greater than or equal to the number of bits in a cell.
000A23r 1               
000A23r 1  rr rr 00 06                  HEADER  6,"RSHIFT",NORMAL
000A27r 1  52 53 48 49  
000A2Br 1  46 54        
000A2Dr 1               RSHIFT:
000A2Dr 1  A6 01                        ldx     <1                      ; Pull bit count
000A2Fr 1  08                           php
000A30r 1  7B                           tdc
000A31r 1  1A                           inc     a                       ; .. from the stack
000A32r 1  1A                           inc     a
000A33r 1  5B                           tcd
000A34r 1  28                           plp
000A35r 1  F0 0A                        beq     RSHIFT_0                ; Zero shift?
000A37r 1  E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
000A3Ar 1  B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
000A3Cr 1  46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
000A3Er 1  CA                           dex                             ; Update count
000A3Fr 1  D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
000A41r 1  BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
000A45r 1  00 00        
000A47r 1  64 01        RSHIFT_2        stz     <1                      ; Clear top value
000A49r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000A4Dr 1  00 00        
000A4Fr 1               
000A4Fr 1               ; XOR ( x1 x2 -- x3 )
000A4Fr 1               ;
000A4Fr 1               ; x3 is the bit-by-bit exclusive-or of x1 with x2.
000A4Fr 1               
000A4Fr 1  rr rr 00 03                  HEADER  3,"XOR",NORMAL
000A53r 1  58 4F 52     
000A56r 1               XOR:
000A56r 1  A5 01                        lda     <1
000A58r 1  45 03                        eor     <3
000A5Ar 1  85 03                        sta     <3
000A5Cr 1  7B                           tdc
000A5Dr 1  1A                           inc     a
000A5Er 1  1A                           inc     a
000A5Fr 1  5B                           tcd
000A60r 1  BB C8 C8 7C                  CONTINUE
000A64r 1  00 00        
000A66r 1               
000A66r 1               ;===============================================================================
000A66r 1               ; Control Words
000A66r 1               ;-------------------------------------------------------------------------------
000A66r 1               
000A66r 1               ; ?ABORT
000A66r 1               ;
000A66r 1               ;   ROT IF TYPE ABORT THEN 2DROP ;
000A66r 1               
000A66r 1  20 rr rr rr  QUERY_ABORT:    jsr     DO_COLON
000A6Ar 1  rr rr rr rr  
000A6Er 1  rr rr rr rr  
000A73r 1                               dw      ROT
000A73r 1                               dw      QUERY_BRANCH,QUERY_ABORT_1
000A73r 1                               dw      TYPE
000A73r 1                               dw      ABORT
000A73r 1  rr rr rr rr  QUERY_ABORT_1:  dw      TWO_DROP
000A77r 1                               dw      EXIT
000A77r 1               
000A77r 1               ; ABORT ( i*x -- ) ( R: j*x -- )
000A77r 1               ;
000A77r 1               ; Empty the data stack and perform the function of QUIT, which includes
000A77r 1               ; emptying the return stack, without displaying a message.
000A77r 1               
000A77r 1  rr rr 00 05                  HEADER  5,"ABORT",NORMAL
000A7Br 1  41 42 4F 52  
000A7Fr 1  54           
000A80r 1  20 rr rr rr  ABORT:          jsr     DO_COLON
000A84r 1  rr rr rr     
000A87r 1                               dw      DO_ABORT
000A87r 1                               dw      QUIT
000A87r 1               
000A87r 1               DO_ABORT:
000A87r 1  A9 7F 01                     lda     #DSTACK_END-1
000A8Ar 1  5B                           tcd
000A8Br 1  BB C8 C8 7C                  CONTINUE
000A8Fr 1  00 00        
000A91r 1               
000A91r 1               ; (BUILD) ( dtc-addr -- )
000A91r 1               ;
000A91r 1               ; Adds a jump the to exection function for the new word.
000A91r 1               
000A91r 1               ;               HEADER  7,"(BUILD)",NORMAL
000A91r 1  20 rr rr rr  BUILD:          jsr     DO_COLON
000A95r 1  rr 20 00 rr  
000A99r 1  rr rr rr rr  
000A9Er 1                               dw      DO_LITERAL,$20
000A9Er 1                               dw      C_COMMA
000A9Er 1                               dw      COMMA
000A9Er 1                               dw      EXIT
000A9Er 1               
000A9Er 1               ; CREATE ( -- )
000A9Er 1               ;
000A9Er 1               ; Skip leading space delimiters. Parse name delimited by a space. Create a
000A9Er 1               ; definition for name with the execution semantics defined below. If the data-
000A9Er 1               ; space pointer is not aligned, reserve enough data space to align it. The new
000A9Er 1               ; data-space pointer defines names data field. CREATE does not allocate data
000A9Er 1               ; space in names data field.
000A9Er 1               
000A9Er 1  rr rr 00 06                  HEADER  6,"CREATE",NORMAL
000AA2r 1  43 52 45 41  
000AA6r 1  54 45        
000AA8r 1  20 rr rr rr  CREATE:         jsr     DO_COLON
000AACr 1  rr rr rr rr  
000AB0r 1  rr rr rr rr  
000AC7r 1                               dw      LATEST
000AC7r 1                               dw      FETCH
000AC7r 1                               dw      COMMA
000AC7r 1                               dw      ZERO
000AC7r 1                               dw      C_COMMA
000AC7r 1                               dw      HERE
000AC7r 1                               dw      LATEST
000AC7r 1                               dw      STORE
000AC7r 1                               dw      BL
000AC7r 1                               dw      WORD
000AC7r 1                               dw      C_FETCH
000AC7r 1                               dw      ONE_PLUS
000AC7r 1                               dw      ALLOT
000AC7r 1                               dw      EXIT
000AC7r 1               
000AC7r 1               ; EXECUTE ( i*x xt -- j*x )
000AC7r 1               ;
000AC7r 1               ; Remove xt from the stack and perform the semantics identified by it. Other
000AC7r 1               ; stack effects are due to the word EXECUTEd.
000AC7r 1               
000AC7r 1  rr rr 00 07                  HEADER  7,"EXECUTE",NORMAL
000ACBr 1  45 58 45 43  
000ACFr 1  55 54 45     
000AD2r 1               EXECUTE:
000AD2r 1  A6 01                        ldx     <1
000AD4r 1  7B                           tdc
000AD5r 1  1A                           inc     a
000AD6r 1  1A                           inc     a
000AD7r 1  5B                           tcd
000AD8r 1  CA                           dex
000AD9r 1  DA                           phx
000ADAr 1  60                           rts
000ADBr 1               
000ADBr 1               ; EXIT ( -- ) ( R: nest-sys -- )
000ADBr 1               ;
000ADBr 1               ; Return control to the calling definition specified by nest-sys. Before
000ADBr 1               ; executing EXIT within a do-loop, a program shall discard the loop-control
000ADBr 1               ; parameters by executing UNLOOP.
000ADBr 1               
000ADBr 1  rr rr 00 04                  HEADER  4,"EXIT",NORMAL
000ADFr 1  45 58 49 54  
000AE3r 1               EXIT:
000AE3r 1  7A                           ply
000AE4r 1  BB C8 C8 7C                  CONTINUE
000AE8r 1  00 00        
000AEAr 1               
000AEAr 1               ; QUIT ( -- ) ( R: i*x -- )
000AEAr 1               ;
000AEAr 1               ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
000AEAr 1               ; user input device the input source, and enter interpretation state. Do not
000AEAr 1               ; display a message. Repeat the following:
000AEAr 1               ;  Accept a line from the input source into the input buffer, set >IN to zero,
000AEAr 1               ;   and interpret.
000AEAr 1               ;  Display the implementation-defined system prompt if in interpretation state,
000AEAr 1               ;   all processing has been completed, and no ambiguous condition exists.
000AEAr 1               ;
000AEAr 1               ; In this implementation it is defined as:
000AEAr 1               ;
000AEAr 1               ;   DO_QUIT 0 STATE !
000AEAr 1               ;   0 (SOURCE-ID) !
000AEAr 1               ;   BEGIN
000AEAr 1               ;     REFILL
000AEAr 1               ;     WHILE SOURCE EVALUATE
000AEAr 1               ;     STATE @ 0= IF S" Ok" CR TYPE THEN
000AEAr 1               ;   AGAIN ;
000AEAr 1               
000AEAr 1  rr rr 00 04                  HEADER  4,"QUIT",NORMAL
000AEEr 1  51 55 49 54  
000AF2r 1  20 rr rr rr  QUIT:           jsr     DO_COLON
000AF6r 1  rr rr rr rr  
000AFAr 1  rr rr rr rr  
000B03r 1                               dw      DO_QUIT
000B03r 1                               dw      ZERO
000B03r 1                               dw      STATE
000B03r 1                               dw      STORE
000B03r 1                               dw      ZERO
000B03r 1                               dw      SOURCEID
000B03r 1                               dw      STORE
000B03r 1  rr rr rr rr  QUIT_1:         dw      REFILL
000B07r 1  rr rr rr rr  
000B0Br 1                               dw      QUERY_BRANCH,QUIT_2
000B0Br 1                               dw      INTERPRET
000B0Br 1  rr rr rr rr  QUIT_2:         dw      STATE
000B0Fr 1  rr rr rr rr  
000B13r 1  rr rr rr rr  
000B1Er 1                               dw      FETCH
000B1Er 1                               dw      ZERO_EQUAL
000B1Er 1                               dw      QUERY_BRANCH,QUIT_3
000B1Er 1                               dw      DO_S_QUOTE
000B1Er 1                               db      2,"Ok"
000B1Er 1                               dw      TYPE
000B1Er 1                               dw      CR
000B1Er 1  rr rr rr rr  QUIT_3:         dw      BRANCH,QUIT_1
000B22r 1               
000B22r 1               DO_QUIT:
000B22r 1  A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
000B25r 1  1B                           tcs
000B26r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000B2Ar 1  00 00        
000B2Cr 1               
000B2Cr 1               ;===============================================================================
000B2Cr 1               ; Parser & Interpreter
000B2Cr 1               ;-------------------------------------------------------------------------------
000B2Cr 1               
000B2Cr 1               ; ?NUMBER
000B2Cr 1               ;
000B2Cr 1               ;   DUP  0 0 ROT COUNT      -- ca ud adr n
000B2Cr 1               ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
000B2Cr 1               ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
000B2Cr 1               ;   ELSE 2DROP NIP R>
000B2Cr 1               ;       IF NEGATE THEN  -1  -- n -1   (ok)
000B2Cr 1               ;   THEN ;
000B2Cr 1               
000B2Cr 1  rr rr 00 07                  HEADER  7,"?NUMBER",NORMAL
000B30r 1  3F 4E 55 4D  
000B34r 1  42 45 52     
000B37r 1  20 rr rr rr  QUERY_NUMBER:   jsr     DO_COLON
000B3Br 1  rr rr rr rr  
000B3Fr 1  rr rr rr rr  
000B5Ar 1                               dw      DUP
000B5Ar 1                               dw      ZERO
000B5Ar 1                               dw      ZERO
000B5Ar 1                               dw      ROT
000B5Ar 1                               dw      COUNT
000B5Ar 1                               dw      QUERY_SIGN
000B5Ar 1                               dw      TO_R
000B5Ar 1                               dw      TO_NUMBER
000B5Ar 1                               dw      QUERY_BRANCH,QNUM_1
000B5Ar 1                               dw      R_FROM
000B5Ar 1                               dw      TWO_DROP
000B5Ar 1                               dw      TWO_DROP
000B5Ar 1                               dw      ZERO
000B5Ar 1                               dw      BRANCH,QNUM_3
000B5Ar 1  rr rr rr rr  QNUM_1:         dw      TWO_DROP
000B5Er 1  rr rr rr rr  
000B62r 1  rr rr rr rr  
000B66r 1                               dw      NIP
000B66r 1                               dw      R_FROM
000B66r 1                               dw      QUERY_BRANCH,QNUM_2
000B66r 1                               dw      NEGATE
000B66r 1  rr rr FF FF  QNUM_2:         dw      DO_LITERAL,$FFFF        ; Was -1
000B6Ar 1  rr rr        QNUM_3:         dw      EXIT
000B6Cr 1               
000B6Cr 1               ; ?SIGN ( c-addr n -- adr' n' f )
000B6Cr 1               ;
000B6Cr 1               ;   OVER C@                 -- adr n c
000B6Cr 1               ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
000B6Cr 1               ;   DUP IF 1+               -- +=0, -=+2
000B6Cr 1               ;       >R 1 /STRING R>     -- adr' n' f
000B6Cr 1               ;   THEN ;
000B6Cr 1               
000B6Cr 1  rr rr 00 05                  HEADER  5,"?SIGN",NORMAL
000B70r 1  3F 53 49 47  
000B74r 1  4E           
000B75r 1  20 rr rr rr  QUERY_SIGN:     jsr     DO_COLON
000B79r 1  rr rr rr rr  
000B7Dr 1  rr 2C 00 rr  
000BA0r 1                               dw      OVER
000BA0r 1                               dw      C_FETCH
000BA0r 1                               dw      DO_LITERAL,','
000BA0r 1                               dw      MINUS
000BA0r 1                               dw      DUP
000BA0r 1                               dw      ABS
000BA0r 1                               dw      DO_LITERAL,1
000BA0r 1                               dw      EQUAL
000BA0r 1                               dw      _AND
000BA0r 1                               dw      DUP
000BA0r 1                               dw      QUERY_BRANCH,QSIGN_1
000BA0r 1                               dw      ONE_PLUS
000BA0r 1                               dw      TO_R
000BA0r 1                               dw      DO_LITERAL,1
000BA0r 1                               dw      SLASH_STRING
000BA0r 1                               dw      R_FROM
000BA0r 1  rr rr        QSIGN_1:        dw      EXIT
000BA2r 1               
000BA2r 1               ; >COUNTED ( c-addr n -- )
000BA2r 1               ;
000BA2r 1               ;   2DUP C! CHAR+ SWAP CMOVE
000BA2r 1               
000BA2r 1  20 rr rr rr  TO_COUNTED:     jsr     DO_COLON
000BA6r 1  rr rr rr rr  
000BAAr 1  rr rr rr rr  
000BB1r 1                               dw      TWO_DUP
000BB1r 1                               dw      C_STORE
000BB1r 1                               dw      CHAR_PLUS
000BB1r 1                               dw      SWAP
000BB1r 1                               dw      CMOVE
000BB1r 1                               dw      EXIT
000BB1r 1               
000BB1r 1               ; >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
000BB1r 1               ;
000BB1r 1               ; ud2 is the unsigned result of converting the characters within the string
000BB1r 1               ; specified by c-addr1 u1 into digits, using the number in BASE, and adding
000BB1r 1               ; each into ud1 after multiplying ud1 by the number in BASE. Conversion
000BB1r 1               ; continues left-to-right until a character that is not convertible, including
000BB1r 1               ; any + or -, is encountered or the string is entirely converted. c-addr2
000BB1r 1               ; is the location of the first unconverted character or the first character
000BB1r 1               ; past the end of the string if the string was entirely converted. u2 is the
000BB1r 1               ; number of unconverted characters in the string. An ambiguous condition exists
000BB1r 1               ; if ud2 overflows during the conversion.
000BB1r 1               ;
000BB1r 1               ; In this implementation its is defined as:
000BB1r 1               ;
000BB1r 1               ;   BEGIN
000BB1r 1               ;   DUP WHILE
000BB1r 1               ;       OVER C@ DIGIT?
000BB1r 1               ;       0= IF DROP EXIT THEN
000BB1r 1               ;       >R 2SWAP BASE @ UD*
000BB1r 1               ;       R> M+ 2SWAP
000BB1r 1               ;       1 /STRING
000BB1r 1               ;   REPEAT ;
000BB1r 1               
000BB1r 1  rr rr 00 07                  HEADER  7,">NUMBER",NORMAL
000BB5r 1  3E 4E 55 4D  
000BB9r 1  42 45 52     
000BBCr 1  20 rr rr     TO_NUMBER:      jsr     DO_COLON
000BBFr 1  rr rr rr rr  TO_NUM_1:       dw      DUP
000BC3r 1  rr rr rr rr  
000BC7r 1  rr rr rr rr  
000BD5r 1                               dw      QUERY_BRANCH,TO_NUM_3
000BD5r 1                               dw      OVER
000BD5r 1                               dw      C_FETCH
000BD5r 1                               dw      DIGIT_QUERY
000BD5r 1                               dw      ZERO_EQUAL
000BD5r 1                               dw      QUERY_BRANCH,TO_NUM_2
000BD5r 1                               dw      DROP
000BD5r 1                               dw      EXIT
000BD5r 1  rr rr rr rr  TO_NUM_2:       dw      TO_R
000BD9r 1  rr rr rr rr  
000BDDr 1  rr rr rr rr  
000BEFr 1                               dw      TWO_SWAP
000BEFr 1                               dw      BASE
000BEFr 1                               dw      FETCH
000BEFr 1                               dw      UD_STAR
000BEFr 1                               dw      R_FROM
000BEFr 1                               dw      M_PLUS
000BEFr 1                               dw      TWO_SWAP
000BEFr 1                               dw      DO_LITERAL,1
000BEFr 1                               dw      SLASH_STRING
000BEFr 1                               dw      BRANCH,TO_NUM_1
000BEFr 1  rr rr        TO_NUM_3:       dw      EXIT
000BF1r 1               
000BF1r 1               ; ACCEPT ( c-addr +n1 -- +n2 )
000BF1r 1               ;
000BF1r 1               ; Receive a string of at most +n1 characters. An ambiguous condition exists if
000BF1r 1               ; +n1 is zero or greater than 32,767. Display graphic characters as they are
000BF1r 1               ; received. A program that depends on the presence or absence of non-graphic
000BF1r 1               ; characters in the string has an environmental dependency. The editing
000BF1r 1               ; functions, if any, that the system performs in order to construct the string
000BF1r 1               ; are implementation-defined.
000BF1r 1               ;
000BF1r 1               ; Input terminates when an implementation-defined line terminator is received.
000BF1r 1               ; When input terminates, nothing is appended to the string, and the display is
000BF1r 1               ; maintained in an implementation-defined way.
000BF1r 1               ;
000BF1r 1               ; +n2 is the length of the string stored at c-addr.
000BF1r 1               ;
000BF1r 1               ; In this implementation it is defined as:
000BF1r 1               ;
000BF1r 1               ;   OVER + 1- OVER      -- sa ea a
000BF1r 1               ;   BEGIN KEY           -- sa ea a c
000BF1r 1               ;   DUP 0D <> WHILE
000BF1r 1               ;     DUP 8 = OVER 127 = OR IF
000BF1r 1               ;       DROP 1-
000BF1r 1               ;       >R OVER R> UMAX
000BF1r 1               ;       8 EMIT SPACE 8 EMIT
000BF1r 1               ;     ELSE
000BF1r 1               ;       DUP EMIT        -- sa ea a c
000BF1r 1               ;       OVER C! 1+ OVER UMIN
000BF1r 1               ;     THEN              -- sa ea a
000BF1r 1               ;   REPEAT              -- sa ea a c
000BF1r 1               ;   DROP NIP SWAP - ;
000BF1r 1               
000BF1r 1  rr rr 00 06                  HEADER  6,"ACCEPT",NORMAL
000BF5r 1  41 43 43 45  
000BF9r 1  50 54        
000BFBr 1  20 rr rr rr  ACCEPT:         jsr     DO_COLON
000BFFr 1  rr rr rr rr  
000C03r 1  rr rr rr     
000C06r 1                               dw      OVER
000C06r 1                               dw      PLUS
000C06r 1                               dw      ONE_MINUS
000C06r 1                               dw      OVER
000C06r 1  rr rr rr rr  ACCEPT_1:       dw      KEY
000C0Ar 1  rr rr 0D 00  
000C0Er 1  rr rr rr rr  
000C48r 1                               dw      DUP
000C48r 1                               dw      DO_LITERAL,$0D
000C48r 1                               dw      NOT_EQUAL
000C48r 1                               dw      QUERY_BRANCH,ACCEPT_4
000C48r 1                               dw      DUP
000C48r 1                               dw      DO_LITERAL,$08
000C48r 1                               dw      EQUAL
000C48r 1                               dw      OVER
000C48r 1                               dw      DO_LITERAL,$7f
000C48r 1                               dw      EQUAL
000C48r 1                               dw      OR
000C48r 1                               dw      QUERY_BRANCH,ACCEPT_2
000C48r 1                               dw      DROP
000C48r 1                               dw      ONE_MINUS
000C48r 1                               dw      TO_R
000C48r 1                               dw      OVER
000C48r 1                               dw      R_FROM
000C48r 1                               dw      UMAX
000C48r 1                               dw      DO_LITERAL,8
000C48r 1                               dw      EMIT
000C48r 1                               dw      SPACE
000C48r 1                               dw      DO_LITERAL,8
000C48r 1                               dw      EMIT
000C48r 1                               dw      BRANCH,ACCEPT_3
000C48r 1  rr rr rr rr  ACCEPT_2:       dw      DUP
000C4Cr 1  rr rr rr rr  
000C50r 1  rr rr rr rr  
000C56r 1                               dw      EMIT
000C56r 1                               dw      OVER
000C56r 1                               dw      C_STORE
000C56r 1                               dw      ONE_PLUS
000C56r 1                               dw      OVER
000C56r 1                               dw      UMIN
000C56r 1  rr rr rr rr  ACCEPT_3:       dw      BRANCH,ACCEPT_1
000C5Ar 1  rr rr rr rr  ACCEPT_4:       dw      DROP
000C5Er 1  rr rr rr rr  
000C62r 1  rr rr        
000C64r 1                               dw      NIP
000C64r 1                               dw      SWAP
000C64r 1                               dw      MINUS
000C64r 1                               dw      EXIT
000C64r 1               
000C64r 1               ; DIGIT?
000C64r 1               ;
000C64r 1               ;   [ HEX ] DUP 39 > 100 AND +     silly looking
000C64r 1               ;   DUP 140 > 107 AND -   30 -     but it works!
000C64r 1               ;   DUP BASE @ U< ;
000C64r 1               
000C64r 1  rr rr 00 06                  HEADER  6,"DIGIT?",NORMAL
000C68r 1  44 49 47 49  
000C6Cr 1  54 3F        
000C6Er 1  20 rr rr rr  DIGIT_QUERY:    jsr     DO_COLON
000C72r 1  rr rr rr 39  
000C76r 1  00 rr rr rr  
000CA1r 1                               dw      DUP
000CA1r 1                               dw      DO_LITERAL,'9'
000CA1r 1                               dw      GREATER
000CA1r 1                               dw      DO_LITERAL,$100
000CA1r 1                               dw      _AND
000CA1r 1                               dw      PLUS
000CA1r 1                               dw      DUP
000CA1r 1                               dw      DO_LITERAL,$140
000CA1r 1                               dw      GREATER
000CA1r 1                               dw      DO_LITERAL,$107
000CA1r 1                               dw      _AND
000CA1r 1                               dw      MINUS
000CA1r 1                               dw      DO_LITERAL,'0'
000CA1r 1                               dw      MINUS
000CA1r 1                               dw      DUP
000CA1r 1                               dw      BASE
000CA1r 1                               dw      FETCH
000CA1r 1                               dw      U_LESS
000CA1r 1                               dw      EXIT
000CA1r 1               
000CA1r 1               ; EVALUATE ( i*x c-addr u -- j*x )
000CA1r 1               ;
000CA1r 1               ; Save the current input source specification. Store minus-one (-1) in
000CA1r 1               ; SOURCE-ID if it is present. Make the string described by c-addr and u both
000CA1r 1               ; the input source and input buffer, set >IN to zero, and interpret. When the
000CA1r 1               ; parse area is empty, restore the prior input source specification. Other
000CA1r 1               ; stack effects are due to the words EVALUATEd.
000CA1r 1               ;
000CA1r 1               ;   >R >R SAVE-INPUT
000CA1r 1               ;   -1 (SOURCE-ID) !
000CA1r 1               ;   0 >IN ! (LENGTH) ! (BUFFER) !
000CA1r 1               ;   INTERPRET
000CA1r 1               ;   RESTORE-INPUT DROP
000CA1r 1               
000CA1r 1  rr rr 00 08                  HEADER  8,"EVALUATE",NORMAL
000CA5r 1  45 56 41 4C  
000CA9r 1  55 41 54 45  
000CADr 1  20 rr rr rr  EVALUATE:       jsr     DO_COLON
000CB1r 1  rr rr rr rr  
000CB5r 1  rr rr rr rr  
000CD6r 1                               dw      TO_R
000CD6r 1                               dw      TO_R
000CD6r 1                               dw      SAVE_INPUT
000CD6r 1                               dw      R_FROM
000CD6r 1                               dw      R_FROM
000CD6r 1                               dw      TRUE
000CD6r 1                               dw      SOURCEID
000CD6r 1                               dw      STORE
000CD6r 1                               dw      ZERO
000CD6r 1                               dw      TO_IN
000CD6r 1                               dw      STORE
000CD6r 1                               dw      LENGTH
000CD6r 1                               dw      STORE
000CD6r 1                               dw      BUFFER
000CD6r 1                               dw      STORE
000CD6r 1                               dw      INTERPRET
000CD6r 1                               dw      RESTORE_INPUT
000CD6r 1                               dw      DROP
000CD6r 1                               dw      EXIT
000CD6r 1               
000CD6r 1               ; INTERPRET ( -- )
000CD6r 1               ;
000CD6r 1               ;
000CD6r 1               ;   BEGIN
000CD6r 1               ;   BL WORD DUP C@ WHILE        -- textadr
000CD6r 1               ;       FIND                    -- a 0/1/-1
000CD6r 1               ;       ?DUP IF                 -- xt 1/-1
000CD6r 1               ;           1+ STATE @ 0= OR    immed or interp?
000CD6r 1               ;           IF EXECUTE ELSE , THEN
000CD6r 1               ;       ELSE                    -- textadr
000CD6r 1               ;           ?NUMBER
000CD6r 1               ;           IF STATE @
000CD6r 1               ;               IF POSTPONE LITERAL THEN     converted ok
000CD6r 1               ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
000CD6r 1               ;           THEN
000CD6r 1               ;       THEN
000CD6r 1               ;   REPEAT DROP ;
000CD6r 1               
000CD6r 1  rr rr 00 09                  HEADER  9,"INTERPRET",NORMAL
000CDAr 1  49 4E 54 45  
000CDEr 1  52 50 52 45  
000CE3r 1  20 rr rr     INTERPRET:      jsr     DO_COLON
000CE6r 1  rr rr rr rr  INTERPRET_1:    dw      BL
000CEAr 1  rr rr rr rr  
000CEEr 1  rr rr rr rr  
000D0Er 1                               dw      WORD
000D0Er 1                               dw      DUP
000D0Er 1                               dw      C_FETCH
000D0Er 1                               dw      QUERY_BRANCH,INTERPRET_7
000D0Er 1                               dw      FIND
000D0Er 1                               dw      QUERY_DUP
000D0Er 1                               dw      QUERY_BRANCH,INTERPRET_4
000D0Er 1                               dw      ONE_PLUS
000D0Er 1                               dw      STATE
000D0Er 1                               dw      FETCH
000D0Er 1                               dw      ZERO_EQUAL
000D0Er 1                               dw      OR
000D0Er 1                               dw      QUERY_BRANCH,INTERPRET_2
000D0Er 1                               dw      EXECUTE
000D0Er 1                               dw      BRANCH,INTERPRET_3
000D0Er 1  rr rr        INTERPRET_2:    dw      COMMA
000D10r 1  rr rr rr rr  INTERPRET_3:    dw      BRANCH,INTERPRET_6
000D14r 1  rr rr rr rr  INTERPRET_4:    dw      QUERY_NUMBER
000D18r 1  rr rr rr rr  
000D1Cr 1  rr rr rr rr  
000D28r 1                               dw      QUERY_BRANCH,INTERPRET_5
000D28r 1                               dw      STATE
000D28r 1                               dw      FETCH
000D28r 1                               dw      QUERY_BRANCH,INTERPRET_6
000D28r 1                               dw      LITERAL
000D28r 1                               dw      BRANCH,INTERPRET_6
000D28r 1  rr rr rr rr  INTERPRET_5:    dw      COUNT
000D2Cr 1  rr rr 3F 00  
000D30r 1  rr rr rr rr  
000D36r 1                               dw      TYPE
000D36r 1                               dw      DO_LITERAL,$3f
000D36r 1                               dw      EMIT
000D36r 1                               dw      CR
000D36r 1                               dw      ABORT
000D36r 1  rr rr rr rr  INTERPRET_6     dw      BRANCH,INTERPRET_1
000D3Ar 1  rr rr rr rr  INTERPRET_7:    dw      DROP
000D3Er 1                               dw      EXIT
000D3Er 1               
000D3Er 1               ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
000D3Er 1               ;
000D3Er 1               ; Find the definition named in the counted string at c-addr. If the definition
000D3Er 1               ; is not found, return c-addr and zero. If the definition is found, return its
000D3Er 1               ; execution token xt. If the definition is immediate, also return one (1),
000D3Er 1               ; otherwise also return minus-one (-1). For a given string, the values returned
000D3Er 1               ; by FIND while compiling may differ from those returned while not compiling.
000D3Er 1               ;
000D3Er 1               ; In this implementation it is defined as:
000D3Er 1               ;
000D3Er 1               ;   LATEST @ BEGIN             -- a nfa
000D3Er 1               ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
000D3Er 1               ;       S=                     -- a nfa f
000D3Er 1               ;       DUP IF
000D3Er 1               ;           DROP
000D3Er 1               ;           NFA>LFA @ DUP      -- a link link
000D3Er 1               ;       THEN
000D3Er 1               ;   0= UNTIL                   -- a nfa  OR  a 0
000D3Er 1               ;   DUP IF
000D3Er 1               ;       NIP DUP NFA>CFA        -- nfa xt
000D3Er 1               ;       SWAP IMMED?            -- xt iflag
000D3Er 1               ;       0= 1 OR                -- xt 1/-1
000D3Er 1               ;   THEN ;
000D3Er 1               
000D3Er 1  rr rr 00 04                  HEADER  4,"FIND",NORMAL
000D42r 1  46 49 4E 44  
000D46r 1  20 rr rr rr  FIND:           jsr     DO_COLON
000D4Ar 1  rr rr rr     
000D4Dr 1                               dw      LATEST
000D4Dr 1                               dw      FETCH
000D4Dr 1  rr rr rr rr  FIND1:          dw      TWO_DUP
000D51r 1  rr rr rr rr  
000D55r 1  rr rr rr rr  
000D65r 1                               dw      OVER
000D65r 1                               dw      C_FETCH
000D65r 1                               dw      CHAR_PLUS
000D65r 1                               dw      S_EQUAL
000D65r 1                               dw      DUP
000D65r 1                               dw      QUERY_BRANCH,FIND2
000D65r 1                               dw      DROP
000D65r 1                               dw      NFA_TO_LFA
000D65r 1                               dw      FETCH
000D65r 1                               dw      DUP
000D65r 1  rr rr rr rr  FIND2:          dw      ZERO_EQUAL
000D69r 1  rr rr rr rr  
000D6Dr 1  rr rr rr rr  
000D83r 1                               dw      QUERY_BRANCH,FIND1
000D83r 1                               dw      DUP
000D83r 1                               dw      QUERY_BRANCH,FIND3
000D83r 1                               dw      NIP
000D83r 1                               dw      DUP
000D83r 1                               dw      NFA_TO_CFA
000D83r 1                               dw      SWAP
000D83r 1                               dw      IMMED_QUERY
000D83r 1                               dw      ZERO_EQUAL
000D83r 1                               dw      DO_LITERAL,1
000D83r 1                               dw      OR
000D83r 1  rr rr        FIND3:          dw      EXIT
000D85r 1               
000D85r 1               ; IMMED? ( nfa -- f )
000D85r 1               
000D85r 1  20 rr rr rr  IMMED_QUERY:    jsr     DO_COLON
000D89r 1  rr rr rr rr  
000D8Dr 1  rr           
000D8Er 1                               dw      ONE_MINUS
000D8Er 1                               dw      C_FETCH
000D8Er 1                               dw      EXIT
000D8Er 1               
000D8Er 1               ; NFA>CFA ( nfa -- cfa )
000D8Er 1               
000D8Er 1  20 rr rr rr  NFA_TO_CFA:     jsr     DO_COLON
000D92r 1  rr rr rr rr  
000D96r 1  rr           
000D97r 1                               dw      COUNT
000D97r 1                               dw      PLUS
000D97r 1                               dw      EXIT
000D97r 1               
000D97r 1               ; NFA>LFA ( nfa -- lfa )
000D97r 1               
000D97r 1  20 rr rr rr  NFA_TO_LFA:     jsr     DO_COLON
000D9Br 1  rr 03 00 rr  
000D9Fr 1  rr rr rr     
000DA2r 1                               dw      DO_LITERAL,3
000DA2r 1                               dw      MINUS
000DA2r 1                               dw      EXIT
000DA2r 1               
000DA2r 1               ; REFILL ( -- flag )
000DA2r 1               ;
000DA2r 1               ; Attempt to fill the input buffer from the input source, returning a true flag
000DA2r 1               ; if successful.
000DA2r 1               ;
000DA2r 1               ; When the input source is the user input device, attempt to receive input into
000DA2r 1               ; the terminal input buffer. If successful, make the result the input buffer,
000DA2r 1               ; set >IN to zero, and return true. Receipt of a line containing no characters
000DA2r 1               ; is considered successful. If there is no input available from the current
000DA2r 1               ; input source, return false.
000DA2r 1               ;
000DA2r 1               ; When the input source is a string from EVALUATE, return false and perform no
000DA2r 1               ; other action.
000DA2r 1               ;
000DA2r 1               ; In this implementation it is defined as:
000DA2r 1               ;
000DA2r 1               ;   SOURCE-ID 0= IF
000DA2r 1               ;     TIB DUP #TIB @ ACCEPT SPACE
000DA2r 1               ;     LENGTH ! BUFFER !
000DA2r 1               ;     0 >IN ! TRUE EXIT
000DA2r 1               ;   THEN
000DA2r 1               ;   FALSE
000DA2r 1               
000DA2r 1  rr rr 00 06                  HEADER  6,"REFILL",NORMAL
000DA6r 1  52 45 46 49  
000DAAr 1  4C 4C        
000DACr 1  20 rr rr rr  REFILL:         jsr     DO_COLON
000DB0r 1  rr rr rr rr  
000DB4r 1  rr rr rr rr  
000DD5r 1                               dw      SOURCE_ID
000DD5r 1                               dw      ZERO_EQUAL
000DD5r 1                               dw      QUERY_BRANCH,REFILL_1
000DD5r 1                               dw      TIB
000DD5r 1                               dw      DUP
000DD5r 1                               dw      HASH_TIB
000DD5r 1                               dw      FETCH
000DD5r 1                               dw      ACCEPT
000DD5r 1                               dw      SPACE
000DD5r 1                               dw      LENGTH
000DD5r 1                               dw      STORE
000DD5r 1                               dw      BUFFER
000DD5r 1                               dw      STORE
000DD5r 1                               dw      ZERO
000DD5r 1                               dw      TO_IN
000DD5r 1                               dw      STORE
000DD5r 1                               dw      TRUE
000DD5r 1                               dw      EXIT
000DD5r 1  rr rr rr rr  REFILL_1:       dw      FALSE
000DD9r 1                               dw      EXIT
000DD9r 1               
000DD9r 1               ; RESTORE-INPUT ( xn ... x1 n -- flag )
000DD9r 1               ;
000DD9r 1               ; Attempt to restore the input source specification to the state described by
000DD9r 1               ; x1 through xn. flag is true if the input source specification cannot be so
000DD9r 1               ; restored.
000DD9r 1               ;
000DD9r 1               ; An ambiguous condition exists if the input source represented by the
000DD9r 1               ; arguments is not the same as the current input source.
000DD9r 1               ;
000DD9r 1               ; In this implementation it is defined as:
000DD9r 1               ;
000DD9r 1               ;   >IN ! (LENGTH) ! BUFFER !
000DD9r 1               ;   SOURCEID !
000DD9r 1               ;   TRUE
000DD9r 1               
000DD9r 1  rr rr 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
000DDDr 1  52 45 53 54  
000DE1r 1  4F 52 45 2D  
000DEAr 1  20 rr rr rr  RESTORE_INPUT   jsr     DO_COLON
000DEEr 1  rr rr rr rr  
000DF2r 1  rr rr rr rr  
000E01r 1                               dw      TO_IN
000E01r 1                               dw      STORE
000E01r 1                               dw      LENGTH
000E01r 1                               dw      STORE
000E01r 1                               dw      BUFFER
000E01r 1                               dw      STORE
000E01r 1                               dw      SOURCEID
000E01r 1                               dw      STORE
000E01r 1                               dw      TRUE
000E01r 1                               dw      EXIT
000E01r 1               
000E01r 1               ; S= ( c-addr1 caddr2 u -- n)
000E01r 1               ;
000E01r 1               ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
000E01r 1               
000E01r 1               S_EQUAL:
000E01r 1  5A                           phy
000E02r 1  A6 01                        ldx     <1                      ; Fetch maximum length
000E04r 1  F0 14                        beq     S_EQUAL_3
000E06r 1  A0 00 00                     ldy     #0
000E09r 1  E2 20                        short_a
000E0Br 1               S_EQUAL_1:
000E0Br 1  B1 05                        lda     (5),y                   ; Compare bytes
000E0Dr 1  D1 03                        cmp     (3),y
000E0Fr 1  D0 06                        bne     S_EQUAL_2
000E11r 1  C8                           iny
000E12r 1  CA                           dex                             ; End of strings?
000E13r 1  D0 F6                        bne     S_EQUAL_1               ; No
000E15r 1  80 03                        bra     S_EQUAL_3               ; Yes. must be the same
000E17r 1               S_EQUAL_2:
000E17r 1  A2 FF FF                     ldx     #$ffff                  ; Difference found
000E1Ar 1               S_EQUAL_3:
000E1Ar 1  C2 20                        long_a
000E1Cr 1  7B                           tdc                             ; Clean up the stack
000E1Dr 1  1A                           inc     a
000E1Er 1  1A                           inc     a
000E1Fr 1  1A                           inc     a
000E20r 1  1A                           inc     a
000E21r 1  5B                           tcd
000E22r 1  86 01                        stx     <1                      ; Save the flag
000E24r 1  7A                           ply
000E25r 1  BB C8 C8 7C                  CONTINUE
000E29r 1  00 00        
000E2Br 1               
000E2Br 1               ; SAVE-INPUT ( -- xn ... x1 n )
000E2Br 1               ;
000E2Br 1               ; x1 through xn describe the current state of the input source specification
000E2Br 1               ; for later use by RESTORE-INPUT.
000E2Br 1               
000E2Br 1  rr rr 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
000E2Fr 1  53 41 56 45  
000E33r 1  2D 49 4E 50  
000E39r 1  20 rr rr rr  SAVE_INPUT:     jsr     DO_COLON
000E3Dr 1  rr rr rr rr  
000E41r 1  rr rr rr rr  
000E4Er 1                               dw      SOURCEID
000E4Er 1                               dw      FETCH
000E4Er 1                               dw      BUFFER
000E4Er 1                               dw      FETCH
000E4Er 1                               dw      LENGTH
000E4Er 1                               dw      FETCH
000E4Er 1                               dw      TO_IN
000E4Er 1                               dw      FETCH
000E4Er 1                               dw      EXIT
000E4Er 1               
000E4Er 1               ; SCAN ( c-addr n c == c-addr' n' )
000E4Er 1               
000E4Er 1               SCAN:
000E4Er 1               SCAN_1:
000E4Er 1  A5 03                        lda     <3                      ; Any data left to scan?
000E50r 1  F0 10                        beq     SCAN_2                  ; No.
000E52r 1  A5 01                        lda     <1                      ; Fetch and compare with scan
000E54r 1  E2 20                        short_a
000E56r 1  D2 05                        cmp     (5)
000E58r 1  C2 20                        long_a
000E5Ar 1  F0 06                        beq     SCAN_2
000E5Cr 1  E6 05                        inc     <5
000E5Er 1  C6 03                        dec     <3
000E60r 1  80 EC                        bra     SCAN_1
000E62r 1               SCAN_2:
000E62r 1  4C rr rr                     jmp     DROP                    ; Drop the character
000E65r 1               
000E65r 1               ; SKIP ( c-addr n c == c-addr' n' )
000E65r 1               
000E65r 1               SKIP:
000E65r 1  A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
000E67r 1  F0 10                        beq     SKIP_2                  ; No.
000E69r 1  A5 01                        lda     <1                      ; Fetch and compare with skip
000E6Br 1  E2 20                        short_a
000E6Dr 1  D2 05                        cmp     (5)
000E6Fr 1  C2 20                        long_a
000E71r 1  D0 06                        bne     SKIP_2                  ; Cannot be skipped
000E73r 1  E6 05                        inc     <5                      ; Bump data address
000E75r 1  C6 03                        dec     <3                      ; and update length
000E77r 1  80 EC                        bra     SKIP_1                  ; And repeat
000E79r 1               SKIP_2:
000E79r 1  4C rr rr                     jmp     DROP                    ; Drop the character
000E7Cr 1               
000E7Cr 1               ; SOURCE ( -- c-addr u )
000E7Cr 1               ;
000E7Cr 1               ; c-addr is the address of, and u is the number of characters in, the input
000E7Cr 1               ; buffer.
000E7Cr 1               ;
000E7Cr 1               ; In this implementation it is defined as
000E7Cr 1               ;
000E7Cr 1               ;   BUFFER @ LENGTH @
000E7Cr 1               
000E7Cr 1  rr rr 00 06                  HEADER  6,"SOURCE",NORMAL
000E80r 1  53 4F 55 52  
000E84r 1  43 45        
000E86r 1  20 rr rr rr  SOURCE:         jsr     DO_COLON
000E8Ar 1  rr rr rr rr  
000E8Er 1  rr rr rr rr  
000E93r 1                               dw      BUFFER
000E93r 1                               dw      FETCH
000E93r 1                               dw      LENGTH
000E93r 1                               dw      FETCH
000E93r 1                               dw      EXIT
000E93r 1               
000E93r 1               ; SOURCE-ID ( -- 0 | -1 )
000E93r 1               ;
000E93r 1               ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
000E93r 1               ; device.
000E93r 1               
000E93r 1  rr rr 00 09                  HEADER  9,"SOURCE-ID",NORMAL
000E97r 1  53 4F 55 52  
000E9Br 1  43 45 2D 49  
000EA0r 1  20 rr rr rr  SOURCE_ID:      jsr     DO_COLON
000EA4r 1  rr rr rr rr  
000EA8r 1  rr           
000EA9r 1                               dw      SOURCEID
000EA9r 1                               dw      FETCH
000EA9r 1                               dw      EXIT
000EA9r 1               
000EA9r 1               ; WORD ( char <chars>ccc<char> -- c-addr )
000EA9r 1               ;
000EA9r 1               ; Skip leading delimiters. Parse characters ccc delimited by char. An
000EA9r 1               ; ambiguous condition exists if the length of the parsed string is greater
000EA9r 1               ; than the implementation-defined length of a counted string.
000EA9r 1               ;
000EA9r 1               ; c-addr is the address of a transient region containing the parsed word as
000EA9r 1               ; a counted string. If the parse area was empty or contained no characters
000EA9r 1               ; other than the delimiter, the resulting string has a zero length. A space,
000EA9r 1               ; not included in the length, follows the string. A program may replace
000EA9r 1               ; characters within the string.
000EA9r 1               ;
000EA9r 1               ; In this implementation it is defined as:
000EA9r 1               ;
000EA9r 1               ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
000EA9r 1               ;   DUP >R   ROT SKIP           -- c adr' n'
000EA9r 1               ;   OVER >R  ROT SCAN           -- adr" n"
000EA9r 1               ;   DUP IF CHAR- THEN        skip trailing delim.
000EA9r 1               ;   R> R> ROT -   >IN +!        update >IN offset
000EA9r 1               ;   TUCK -                      -- adr' N
000EA9r 1               ;   HERE >counted               --
000EA9r 1               ;   HERE                        -- a
000EA9r 1               ;   BL OVER COUNT + C! ;    append trailing blank
000EA9r 1               
000EA9r 1  rr rr 00 04                  HEADER  4,"WORD",NORMAL
000EADr 1  57 4F 52 44  
000EB1r 1  20 rr rr rr  WORD:           jsr     DO_COLON
000EB5r 1  rr rr rr rr  
000EB9r 1  rr rr rr rr  
000ED6r 1                               dw      DUP
000ED6r 1                               dw      SOURCE
000ED6r 1                               dw      TO_IN
000ED6r 1                               dw      FETCH
000ED6r 1                               dw      SLASH_STRING
000ED6r 1                               dw      DUP
000ED6r 1                               dw      TO_R
000ED6r 1                               dw      ROT
000ED6r 1                               dw      SKIP
000ED6r 1                               dw      OVER
000ED6r 1                               dw      TO_R
000ED6r 1                               dw      ROT
000ED6r 1                               dw      SCAN
000ED6r 1                               dw      DUP
000ED6r 1                               dw      QUERY_BRANCH,WORD_1
000ED6r 1                               dw      CHAR_MINUS
000ED6r 1  rr rr rr rr  WORD_1:         dw      R_FROM
000EDAr 1  rr rr rr rr  
000EDEr 1  rr rr rr rr  
000EF8r 1                               dw      R_FROM
000EF8r 1                               dw      ROT
000EF8r 1                               dw      MINUS
000EF8r 1                               dw      TO_IN
000EF8r 1                               dw      PLUS_STORE
000EF8r 1                               dw      TUCK
000EF8r 1                               dw      MINUS
000EF8r 1                               dw      HERE
000EF8r 1                               dw      TO_COUNTED
000EF8r 1                               dw      HERE
000EF8r 1                               dw      BL
000EF8r 1                               dw      OVER
000EF8r 1                               dw      COUNT
000EF8r 1                               dw      PLUS
000EF8r 1                               dw      C_STORE
000EF8r 1                               dw      EXIT
000EF8r 1               
000EF8r 1               ;===============================================================================
000EF8r 1               ; String Words
000EF8r 1               ;-------------------------------------------------------------------------------
000EF8r 1               
000EF8r 1               ; -TRAILING ( c-addr u1 -- c-addr u2 )
000EF8r 1               ;
000EF8r 1               ; If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
000EF8r 1               ; the end of the character string specified by c-addr u1. If u1 is zero or the
000EF8r 1               ; entire string consists of spaces, u2 is zero.
000EF8r 1               
000EF8r 1  rr rr 00 09                  HEADER  9,"-TRAILING",NORMAL
000EFCr 1  2D 54 52 41  
000F00r 1  49 4C 49 4E  
000F05r 1               DASH_TRAILING:
000F05r 1  5A                           phy                             ; Save IP
000F06r 1  A4 01                        ldy     <1                      ; Is u1 > 0?
000F08r 1  F0 0F                        beq     DASH_TRAIL_3            ; No
000F0Ar 1  E2 20                        short_a
000F0Cr 1  88                           dey                             ; Convert to offset
000F0Dr 1  B1 03        DASH_TRAIL_1:   lda     (3),y                   ; Space character at end?
000F0Fr 1  C9 20                        cmp     #' '
000F11r 1  D0 03                        bne     DASH_TRAIL_2            ; No
000F13r 1  88                           dey                             ; More characters to check?
000F14r 1  10 F7                        bpl     DASH_TRAIL_1            ; Yes
000F16r 1  C2 20        DASH_TRAIL_2:   long_a
000F18r 1  C8                           iny                             ; Convert to length
000F19r 1  84 01        DASH_TRAIL_3:   sty     <1                      ; Update
000F1Br 1  7A                           ply                             ; Restore IP
000F1Cr 1  BB C8 C8 7C                  CONTINUE                        ; Done
000F20r 1  00 00        
000F22r 1               
000F22r 1               ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
000F22r 1               ;
000F22r 1               ; Adjust the character string at c-addr1 by n characters. The resulting
000F22r 1               ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
000F22r 1               ; characters and is u1 minus n characters long.
000F22r 1               ;
000F22r 1               ; In this implementation it is defined as:
000F22r 1               ;
000F22r 1               ;   ROT OVER + ROT ROT -
000F22r 1               
000F22r 1  rr rr 00 07                  HEADER  7,"/STRING",NORMAL
000F26r 1  2F 53 54 52  
000F2Ar 1  49 4E 47     
000F2Dr 1  20 rr rr rr  SLASH_STRING:   jsr     DO_COLON
000F31r 1  rr rr rr rr  
000F35r 1  rr rr rr rr  
000F3Er 1                               dw      ROT
000F3Er 1                               dw      OVER
000F3Er 1                               dw      PLUS
000F3Er 1                               dw      ROT
000F3Er 1                               dw      ROT
000F3Er 1                               dw      MINUS
000F3Er 1                               dw      EXIT
000F3Er 1               
000F3Er 1               ; BLANK ( c-addr u -- )
000F3Er 1               ;
000F3Er 1               ; If u is greater than zero, store the character value for space in u
000F3Er 1               ; consecutive character positions beginning at c-addr.
000F3Er 1               ;
000F3Er 1               ; In this implementation it is defined as
000F3Er 1               ;
000F3Er 1               ;   ?DUP IF OVER + SWAP DO BL I C! LOOP ELSE DROP THEN
000F3Er 1               
000F3Er 1  rr rr 00 05                  HEADER  5,"BLANK",NORMAL
000F42r 1  42 4C 41 4E  
000F46r 1  4B           
000F47r 1  20 rr rr rr  BLANK:          jsr     DO_COLON
000F4Br 1  rr rr rr rr  
000F4Fr 1  rr rr rr rr  
000F58r 1                               dw      QUERY_DUP
000F58r 1                               dw      QUERY_BRANCH,BLANK_2
000F58r 1                               dw      OVER
000F58r 1                               dw      PLUS
000F58r 1                               dw      SWAP
000F58r 1                               dw      DO_DO
000F58r 1  rr rr rr rr  BLANK_1:        dw      BL
000F5Cr 1  rr rr rr rr  
000F60r 1  rr rr rr rr  
000F64r 1                               dw      I
000F64r 1                               dw      C_STORE
000F64r 1                               dw      DO_LOOP,BLANK_1
000F64r 1                               dw      EXIT
000F64r 1  rr rr rr rr  BLANK_2:        dw      DROP
000F68r 1                               dw      EXIT
000F68r 1               
000F68r 1               ; CMOVE ( c-addr1 c-addr2 u -- )
000F68r 1               ;
000F68r 1               ; If u is greater than zero, copy u consecutive characters from the data space
000F68r 1               ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
000F68r 1               ; character from lower addresses to higher addresses.
000F68r 1               
000F68r 1  rr rr 00 05                  HEADER  5,"CMOVE",NORMAL
000F6Cr 1  43 4D 4F 56  
000F70r 1  45           
000F71r 1               CMOVE:
000F71r 1  5A                           phy
000F72r 1  A6 01                        ldx     <1                      ; Any characters to move?
000F74r 1  F0 0F                        beq     CMOVE_2                 ; No
000F76r 1  A0 00 00                     ldy     #0
000F79r 1  E2 20                        short_a
000F7Br 1               CMOVE_1:                                        ; Transfer a byte
000F7Br 1  B1 05                        lda     (5),y
000F7Dr 1  91 03                        sta     (3),y
000F7Fr 1  C8                           iny
000F80r 1  CA                           dex                             ; Decrement count
000F81r 1  D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
000F83r 1  C2 20                        long_a
000F85r 1               CMOVE_2:
000F85r 1  7B                           tdc                             ; Clean up the stack
000F86r 1  18                           clc
000F87r 1  69 06 00                     adc     #6
000F8Ar 1  5B                           tcd
000F8Br 1  7A                           ply
000F8Cr 1  BB C8 C8 7C                  CONTINUE                        ; Done
000F90r 1  00 00        
000F92r 1               
000F92r 1               ; CMOVE> ( c-addr1 c-addr2 u -- )
000F92r 1               ;
000F92r 1               ; If u is greater than zero, copy u consecutive characters from the data space
000F92r 1               ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
000F92r 1               ; character from higher addresses to lower addresses.
000F92r 1               
000F92r 1  rr rr 00 06                  HEADER  6,"CMOVE>",NORMAL
000F96r 1  43 4D 4F 56  
000F9Ar 1  45 3E        
000F9Cr 1               CMOVE_GREATER:
000F9Cr 1  5A                           phy
000F9Dr 1  A6 01                        ldx     <1                      ; Any characters to move?
000F9Fr 1  F0 0E                        beq     CMOVE_GT_2              ; No.
000FA1r 1  A4 01                        ldy     <1
000FA3r 1  E2 20                        short_a
000FA5r 1               CMOVE_GT_1:
000FA5r 1  88                           dey                             ; Transfer a byte
000FA6r 1  B1 05                        lda     (5),y
000FA8r 1  91 03                        sta     (3),y
000FAAr 1  CA                           dex                             ; Decrement length
000FABr 1  D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
000FADr 1  C2 20                        long_a
000FAFr 1               CMOVE_GT_2:
000FAFr 1  7B                           tdc                             ; Clean up the stack
000FB0r 1  18                           clc
000FB1r 1  69 06 00                     adc     #6
000FB4r 1  5B                           tcd
000FB5r 1  7A                           ply
000FB6r 1  BB C8 C8 7C                  CONTINUE                        ; Done
000FBAr 1  00 00        
000FBCr 1               
000FBCr 1               ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
000FBCr 1               ;
000FBCr 1               ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
000FBCr 1               ; u2. The strings are compared, beginning at the given addresses, character by
000FBCr 1               ; character, up to the length of the shorter string or until a difference is
000FBCr 1               ; found. If the two strings are identical, n is zero. If the two strings are
000FBCr 1               ; identical up to the length of the shorter string, n is minus-one (-1) if u1
000FBCr 1               ; is less than u2 and one (1) otherwise. If the two strings are not identical
000FBCr 1               ; up to the length of the shorter string, n is minus-one (-1) if the first
000FBCr 1               ; non-matching character in the string specified by c-addr1 u1 has a lesser
000FBCr 1               ; numeric value than the corresponding character in the string specified by
000FBCr 1               ; c-addr2 u2 and one (1) otherwise.
000FBCr 1               
000FBCr 1  rr rr 00 07                  HEADER  7,"COMPARE",NORMAL
000FC0r 1  43 4F 4D 50  
000FC4r 1  41 52 45     
000FC7r 1               COMPARE:
000FC7r 1  A5 01                        lda     <1                      ; Both string lengths zero?
000FC9r 1  05 05                        ora     <5
000FCBr 1  F0 26                        beq     COMPARE_X               ; Yes, must be equal
000FCDr 1               
000FCDr 1  A5 01                        lda     <1                      ; Second string length zero?
000FCFr 1  F0 1A                        beq     COMPARE_P               ; Yes, must be shorter
000FD1r 1  A5 05                        lda     <5                      ; First string length zero?
000FD3r 1  F0 1B                        beq     COMPARE_N               ; Yes, must be shorter
000FD5r 1  E2 20                        short_a
000FD7r 1  B2 07                        lda     (7)                     ; Compare next characters
000FD9r 1  D2 03                        cmp     (3)
000FDBr 1  C2 20                        long_a
000FDDr 1  90 11                        bcc     COMPARE_N
000FDFr 1  D0 0A                        bne     COMPARE_P
000FE1r 1               
000FE1r 1  E6 03                        inc     <3                      ; Bump string pointers
000FE3r 1  E6 07                        inc     <7
000FE5r 1  C6 01                        dec     <1                      ; And reduce lengths
000FE7r 1  C6 05                        dec     <5
000FE9r 1  80 DC                        bra     COMPARE
000FEBr 1               
000FEBr 1  A9 01 00     COMPARE_P:      lda     #1
000FEEr 1  80 03                        bra     COMPARE_X
000FF0r 1  A9 FF FF     COMPARE_N:      lda     #$FFFF        ; Was -1
000FF3r 1               
000FF3r 1  85 07        COMPARE_X:      sta     <7                      ; Save the result
000FF5r 1  7B                           tdc
000FF6r 1  18                           clc
000FF7r 1  69 06 00                     adc     #6
000FFAr 1  5B                           tcd
000FFBr 1  BB C8 C8 7C                  CONTINUE                        ; Done
000FFFr 1  00 00        
001001r 1               
001001r 1               ; COUNT ( c-addr1 -- c-addr2 u )
001001r 1               ;
001001r 1               ; Return the character string specification for the counted string stored at
001001r 1               ; c-addr1. c-addr2 is the address of the first character after c-addr1. u is
001001r 1               ; the contents of the character at c-addr1, which is the length in characters
001001r 1               ; of the string at c-addr2.
001001r 1               ;
001001r 1               ; In this implementation it is defined as
001001r 1               ;
001001r 1               ;   DUP CHAR+ SWAP C@
001001r 1               
001001r 1  rr rr 00 05                  HEADER  5,"COUNT",NORMAL
001005r 1  43 4F 55 4E  
001009r 1  54           
00100Ar 1  20 rr rr rr  COUNT:          jsr     DO_COLON
00100Er 1  rr rr rr rr  
001012r 1  rr rr rr rr  
001017r 1                               dw      DUP
001017r 1                               dw      CHAR_PLUS
001017r 1                               dw      SWAP
001017r 1                               dw      C_FETCH
001017r 1                               dw      EXIT
001017r 1               
001017r 1               ; SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
001017r 1               ;
001017r 1               ; Search the string specified by c-addr1 u1 for the string specified by c-addr2
001017r 1               ; u2. If flag is true, a match was found at c-addr3 with u3 characters
001017r 1               ; remaining. If flag is false there was no match and c-addr3 is c-addr1 and u3
001017r 1               ; is u1.
001017r 1               
001017r 1  rr rr 00 06                  HEADER  6,"SEARCH",NORMAL
00101Br 1  53 45 41 52  
00101Fr 1  43 48        
001021r 1  20 rr rr     SEARCH:         jsr     DO_COLON
001024r 1               ; TODO
001024r 1  BB C8 C8 7C                  CONTINUE
001028r 1  00 00        
00102Ar 1               
00102Ar 1               ;===============================================================================
00102Ar 1               ; Compiling Words
00102Ar 1               ;-------------------------------------------------------------------------------
00102Ar 1               
00102Ar 1               ; ( ( -- )
00102Ar 1               ;
00102Ar 1               ; Parse ccc delimited by ) (right parenthesis). ( is an immediate word.
00102Ar 1               ;
00102Ar 1               ; The number of characters in ccc may be zero to the number of characters in the
00102Ar 1               ; parse area.
00102Ar 1               ;
00102Ar 1               ; In this implementation it is defined as:
00102Ar 1               ;
00102Ar 1               ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
00102Ar 1               
00102Ar 1  rr rr 80 01                  HEADER  1,"(",IMMEDIATE
00102Er 1  28           
00102Fr 1  20 rr rr rr                  jsr     DO_COLON
001033r 1  rr 29 00 rr  
001037r 1  rr rr rr rr  
00103Cr 1                               dw      DO_LITERAL,')'
00103Cr 1                               dw      WORD
00103Cr 1                               dw      DROP
00103Cr 1                               dw      EXIT
00103Cr 1               
00103Cr 1               ; .(
00103Cr 1               
00103Cr 1  rr rr 80 02                  HEADER  2,".(",IMMEDIATE
001040r 1  2E 28        
001042r 1  20 rr rr rr  DOT_PAREN:      jsr     DO_COLON
001046r 1  rr 29 00 rr  
00104Ar 1  rr rr rr rr  
001051r 1                               dw      DO_LITERAL,')'
001051r 1                               dw      WORD
001051r 1                               dw      COUNT
001051r 1                               dw      TYPE
001051r 1                               dw      EXIT
001051r 1               
001051r 1               ; ." ( -- )
001051r 1               
001051r 1  rr rr 80 02                  LINK    IMMEDIATE
001055r 1  2E 22        
001057r 1                               db      2,".",'"'
001057r 1  20 rr rr rr  DOT_QUOTE:      jsr     DO_COLON
00105Br 1  rr rr rr rr  
00105Fr 1  rr rr rr rr  
001064r 1                               dw      S_QUOTE
001064r 1                               dw      DO_LITERAL,TYPE
001064r 1                               dw      COMMA
001064r 1                               dw      EXIT
001064r 1               
001064r 1               
001064r 1               ; +LOOP ( -- )
001064r 1               
001064r 1  rr rr 80 05                  HEADER  5,"+LOOP",IMMEDIATE
001068r 1  2B 4C 4F 4F  
00106Cr 1  50           
00106Dr 1  20 rr rr rr  PLUS_LOOP:      jsr     DO_COLON
001071r 1  rr rr rr rr  
001075r 1  rr rr rr rr  
001084r 1                               dw      DO_LITERAL,DO_PLUS_LOOP
001084r 1                               dw      COMMA
001084r 1                               dw      COMMA
001084r 1                               dw      QUERY_DUP
001084r 1                               dw      QUERY_BRANCH,PLUS_LOOP_1
001084r 1                               dw      HERE
001084r 1                               dw      SWAP
001084r 1                               dw      STORE
001084r 1  rr rr        PLUS_LOOP_1:    dw      EXIT
001086r 1               
001086r 1               DO_PLUS_LOOP:
001086r 1  A6 01                        ldx     <1                      ; Fetch increment
001088r 1  7B                           tdc                             ; And drop
001089r 1  1A                           inc     a
00108Ar 1  1A                           inc     a
00108Br 1  5B                           tcd
00108Cr 1  18                           clc                             ; Add to loop counter
00108Dr 1  8A                           txa
00108Er 1  63 01                        adc     1,s
001090r 1  83 01                        sta     1,s
001092r 1  C3 03                        cmp     3,s                     ; Reached limit?
001094r 1  B0 0A                        bcs     DO_PLOOP_END            ; Yes
001096r 1  B9 00 00                     lda     0,y                     ; No, branch back to start
001099r 1  A8                           tay
00109Ar 1  BB C8 C8 7C                  CONTINUE                        ; Done
00109Er 1  00 00        
0010A0r 1               
0010A0r 1  C8           DO_PLOOP_END:   iny                             ; Skip over address
0010A1r 1  C8                           iny
0010A2r 1  68                           pla                             ; Drop loop variables
0010A3r 1  68                           pla
0010A4r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0010A8r 1  00 00        
0010AAr 1               
0010AAr 1               ; : ( -- )
0010AAr 1               
0010AAr 1  rr rr 00 01                  HEADER  1,":",NORMAL
0010AEr 1  3A           
0010AFr 1  20 rr rr rr  COLON:          jsr     DO_COLON
0010B3r 1  rr rr rr rr  
0010B7r 1  rr rr rr rr  
0010BEr 1                               dw      CREATE
0010BEr 1                               dw      DO_LITERAL,DO_COLON
0010BEr 1                               dw      BUILD
0010BEr 1                               dw      RIGHT_BRACKET
0010BEr 1                               dw      EXIT
0010BEr 1               
0010BEr 1               DO_COLON:
0010BEr 1  FA                           plx                             ; Pull new word IP-1
0010BFr 1  5A                           phy                             ; Save the old IP
0010C0r 1  E8                           inx                             ; Work out new IP
0010C1r 1  9B                           txy
0010C2r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0010C6r 1  00 00        
0010C8r 1               
0010C8r 1               ; :NONAME ( -- xt )
0010C8r 1               
0010C8r 1  rr rr 00 07                  HEADER  7,":NONAME",NORMAL
0010CCr 1  3A 4E 4F 4E  
0010D0r 1  41 4D 45     
0010D3r 1  20 rr rr rr  NONAME:         jsr     DO_COLON
0010D7r 1  rr rr rr rr  
0010DBr 1  rr rr rr rr  
0010E2r 1                               dw      HERE
0010E2r 1                               dw      DO_LITERAL,DO_COLON
0010E2r 1                               dw      BUILD
0010E2r 1                               dw      RIGHT_BRACKET
0010E2r 1                               dw      EXIT
0010E2r 1               
0010E2r 1               ; ; ( -- )
0010E2r 1               
0010E2r 1  rr rr 80 01                  LINK    IMMEDIATE
0010E6r 1  3B           
0010E7r 1                               db      1,";"
0010E7r 1  20 rr rr rr  SEMICOLON:      jsr     DO_COLON
0010EBr 1  rr rr rr rr  
0010EFr 1  rr rr rr rr  
0010F4r 1                               dw      DO_LITERAL,EXIT
0010F4r 1                               dw      COMMA
0010F4r 1                               dw      LEFT_BRACKET
0010F4r 1                               dw      EXIT
0010F4r 1               
0010F4r 1               ; ?DO ( -- )
0010F4r 1               
0010F4r 1  rr rr 80 03                  HEADER  3,"?DO",IMMEDIATE
0010F8r 1  3F 44 4F     
0010FBr 1  20 rr rr rr  QUERY_DO:       jsr     DO_COLON
0010FFr 1  rr rr rr rr  
001103r 1  rr rr rr rr  
00110Er 1                               dw      DO_LITERAL,QUERY_DO_DO
00110Er 1                               dw      COMMA
00110Er 1                               dw      HERE
00110Er 1                               dw      ZERO
00110Er 1                               dw      COMMA
00110Er 1                               dw      HERE
00110Er 1                               dw      EXIT
00110Er 1               
00110Er 1               QUERY_DO_DO:
00110Er 1  A5 01                        lda     <1                      ; Are the start and limit
001110r 1  45 03                        eor     <3                      ; .. the same?
001112r 1  F0 05                        beq     QUERY_DO_DO_1
001114r 1  C8                           iny                             ; No, Skip over jump address
001115r 1  C8                           iny
001116r 1  4C rr rr                     jmp     DO_DO                   ; And start a normal loop
001119r 1               
001119r 1  7B           QUERY_DO_DO_1:  tdc                             ; Drop the loop parameters
00111Ar 1  1A                           inc     a
00111Br 1  1A                           inc     a
00111Cr 1  1A                           inc     a
00111Dr 1  1A                           inc     a
00111Er 1  5B                           tcd
00111Fr 1  4C rr rr                     jmp     BRANCH                  ; And skip over loop
001122r 1               
001122r 1               ; 2CONSTANT ( x <spaces>name -- )
001122r 1               ;
001122r 1               ; Skip leading space delimiters. Parse name delimited by a space. Create a
001122r 1               ; definition for name with the execution semantics defined below.
001122r 1               
001122r 1  rr rr 00 09                  HEADER  9,"2CONSTANT",NORMAL
001126r 1  32 43 4F 4E  
00112Ar 1  53 54 41 4E  
00112Fr 1  20 rr rr rr  TWO_CONSTANT:   jsr     DO_COLON
001133r 1  rr rr rr rr  
001137r 1  rr rr rr rr  
001140r 1                               dw      CREATE
001140r 1                               dw      DO_LITERAL,DO_TWO_CONSTANT
001140r 1                               dw      BUILD
001140r 1                               dw      COMMA
001140r 1                               dw      COMMA
001140r 1                               dw      EXIT; AGAIN ( -- )
001140r 1               
001140r 1               DO_TWO_CONSTANT:
001140r 1  FA                           plx                             ; Get return address
001141r 1  7B                           tdc                             ; Create space on stack
001142r 1  3A                           dec     a
001143r 1  3A                           dec     a
001144r 1  3A                           dec     a
001145r 1  3A                           dec     a
001146r 1  5B                           tcd
001147r 1  BD 01 00                     lda     a:1,x                    ; Transfer the value
00114Ar 1  85 01                        sta     <1
00114Cr 1  BD 03 00                     lda     a:3,x
00114Fr 1  85 03                        sta     <3
001151r 1  BB C8 C8 7C                  CONTINUE                        ; Done
001155r 1  00 00        
001157r 1               
001157r 1               ; 2LITERAL
001157r 1               
001157r 1  rr rr 80 08                  HEADER  8,"2LITERAL",IMMEDIATE
00115Br 1  32 4C 49 54  
00115Fr 1  45 52 41 4C  
001163r 1  20 rr rr rr  TWO_LITERAL:    jsr     DO_COLON
001167r 1  rr rr rr rr  
00116Br 1  rr rr rr rr  
001172r 1                               dw      DO_LITERAL,DO_TWO_LITERAL
001172r 1                               dw      COMMA
001172r 1                               dw      COMMA
001172r 1                               dw      COMMA
001172r 1                               dw      EXIT
001172r 1               
001172r 1               DO_TWO_LITERAL:
001172r 1  7B                           tdc                             ; Make room on stack
001173r 1  3A                           dec     a
001174r 1  3A                           dec     a
001175r 1  3A                           dec     a
001176r 1  3A                           dec     a
001177r 1  5B                           tcd
001178r 1  B9 00 00                     lda     0,y                     ; Fetch constant from IP
00117Br 1  85 01                        sta     <1
00117Dr 1  B9 02 00                     lda     2,y
001180r 1  85 03                        sta     <3
001182r 1  C8                           iny                             ; Bump IP
001183r 1  C8                           iny
001184r 1  C8                           iny
001185r 1  C8                           iny
001186r 1  BB C8 C8 7C                  CONTINUE                        ; Done
00118Ar 1  00 00        
00118Cr 1               
00118Cr 1               ; 2VARIABLE
00118Cr 1               
00118Cr 1  rr rr 80 09                  HEADER  9,"2VARIABLE",IMMEDIATE
001190r 1  32 56 41 52  
001194r 1  49 41 42 4C  
001199r 1  20 rr rr rr  TWO_VARIABLE:   jsr     DO_COLON
00119Dr 1  rr rr rr rr  
0011A1r 1  rr rr rr rr  
0011AEr 1                               dw      CREATE
0011AEr 1                               dw      DO_LITERAL,DO_VARIABLE
0011AEr 1                               dw      BUILD
0011AEr 1                               dw      DO_LITERAL,2
0011AEr 1                               dw      CELLS
0011AEr 1                               dw      ALLOT
0011AEr 1                               dw      EXIT
0011AEr 1               
0011AEr 1               ; ABORT" ( -- )
0011AEr 1               
0011AEr 1  rr rr 80 06                  LINK    IMMEDIATE
0011B2r 1  41 42 4F 52  
0011B6r 1  54 22        
0011B8r 1                               db      6,"ABORT",'"'
0011B8r 1  20 rr rr rr  ABORT_QUOTE:    jsr     DO_COLON
0011BCr 1  rr rr rr rr  
0011C0r 1  rr rr rr rr  
0011C5r 1                               dw      S_QUOTE
0011C5r 1                               dw      DO_LITERAL,QUERY_ABORT
0011C5r 1                               dw      COMMA
0011C5r 1                               dw      EXIT
0011C5r 1               
0011C5r 1               ; AGAIN ( -- )
0011C5r 1  rr rr 80 05                  HEADER  5,"AGAIN",IMMEDIATE
0011C9r 1  41 47 41 49  
0011CDr 1  4E           
0011CEr 1  20 rr rr rr  AGAIN:          jsr     DO_COLON
0011D2r 1  rr rr rr rr  
0011D6r 1  rr rr rr rr  
0011DBr 1                               dw      DO_LITERAL,BRANCH
0011DBr 1                               dw      COMMA
0011DBr 1                               dw      COMMA
0011DBr 1                               dw      EXIT
0011DBr 1               
0011DBr 1               ; BEGIN ( -- )
0011DBr 1               
0011DBr 1  rr rr 80 05                  HEADER  5,"BEGIN",IMMEDIATE
0011DFr 1  42 45 47 49  
0011E3r 1  4E           
0011E4r 1  20 rr rr rr  BEGIN:          jsr     DO_COLON
0011E8r 1  rr rr rr     
0011EBr 1                               dw      HERE
0011EBr 1                               dw      EXIT
0011EBr 1               
0011EBr 1               ; CONSTANT ( x <spaces>name -- )
0011EBr 1               ;
0011EBr 1               ; Skip leading space delimiters. Parse name delimited by a space. Create a
0011EBr 1               ; definition for name with the execution semantics defined below.
0011EBr 1               
0011EBr 1  rr rr 00 08                  HEADER  8,"CONSTANT",NORMAL
0011EFr 1  43 4F 4E 53  
0011F3r 1  54 41 4E 54  
0011F7r 1  20 rr rr rr  CONSTANT:       jsr     DO_COLON
0011FBr 1  rr rr rr rr  
0011FFr 1  rr rr rr rr  
001206r 1                               dw      CREATE
001206r 1                               dw      DO_LITERAL,DO_CONSTANT
001206r 1                               dw      BUILD
001206r 1                               dw      COMMA
001206r 1                               dw      EXIT
001206r 1               
001206r 1               DO_CONSTANT:
001206r 1  FA                           plx                             ; Get return address
001207r 1  7B                           tdc                             ; Create space on stack
001208r 1  3A                           dec     a
001209r 1  3A                           dec     a
00120Ar 1  5B                           tcd
00120Br 1  BD 01 00                     lda     a:1,x                    ; Transfer the value
00120Er 1  85 01                        sta     <1
001210r 1  BB C8 C8 7C                  CONTINUE                        ; Done
001214r 1  00 00        
001216r 1               
001216r 1               ; DO ( -- )
001216r 1               
001216r 1  rr rr 80 02                  HEADER  2,"DO",IMMEDIATE
00121Ar 1  44 4F        
00121Cr 1  20 rr rr rr  DO:             jsr     DO_COLON
001220r 1  rr rr rr rr  
001224r 1  rr rr rr rr  
00122Br 1                               dw      DO_LITERAL,DO_DO
00122Br 1                               dw      COMMA
00122Br 1                               dw      ZERO
00122Br 1                               dw      HERE
00122Br 1                               dw      EXIT
00122Br 1               
00122Br 1               DO_DO:
00122Br 1  A5 03                        lda     <3
00122Dr 1  48                           pha
00122Er 1  A5 01                        lda     <1
001230r 1  48                           pha
001231r 1  7B                           tdc
001232r 1  1A                           inc     a
001233r 1  1A                           inc     a
001234r 1  1A                           inc     a
001235r 1  1A                           inc     a
001236r 1  5B                           tcd
001237r 1  BB C8 C8 7C                  CONTINUE
00123Br 1  00 00        
00123Dr 1               
00123Dr 1               ; ELSE ( -- )
00123Dr 1               
00123Dr 1  rr rr 80 04                  HEADER  4,"ELSE",IMMEDIATE
001241r 1  45 4C 53 45  
001245r 1  20 rr rr rr  ELSE:           jsr     DO_COLON
001249r 1  rr rr rr rr  
00124Dr 1  rr rr rr rr  
00125Cr 1                               dw      DO_LITERAL,BRANCH
00125Cr 1                               dw      COMMA
00125Cr 1                               dw      HERE
00125Cr 1                               dw      ZERO
00125Cr 1                               dw      COMMA
00125Cr 1                               dw      HERE
00125Cr 1                               dw      SWAP
00125Cr 1                               dw      STORE
00125Cr 1                               dw      EXIT
00125Cr 1               
00125Cr 1               BRANCH:
00125Cr 1  B9 00 00                     lda     0,y                     ; Load branch address into IP
00125Fr 1  A8                           tay
001260r 1  BB C8 C8 7C                  CONTINUE                        ; Done
001264r 1  00 00        
001266r 1               
001266r 1               ; IF ( -- )
001266r 1               
001266r 1  rr rr 80 02                  HEADER  2,"IF",IMMEDIATE
00126Ar 1  49 46        
00126Cr 1  20 rr rr rr  IF:             jsr     DO_COLON
001270r 1  rr rr rr rr  
001274r 1  rr rr rr rr  
00127Dr 1                               dw      DO_LITERAL,QUERY_BRANCH
00127Dr 1                               dw      COMMA
00127Dr 1                               dw      HERE
00127Dr 1                               dw      ZERO
00127Dr 1                               dw      COMMA
00127Dr 1                               dw      EXIT
00127Dr 1               
00127Dr 1               QUERY_BRANCH:
00127Dr 1  A6 01                        ldx     <1                      ; Pull the top of stack value
00127Fr 1  7B                           tdc
001280r 1  1A                           inc     a                       ; Drop top item
001281r 1  1A                           inc     a
001282r 1  5B                           tcd
001283r 1  8A                           txa
001284r 1  F0 D6                        beq     BRANCH                  ; Branch if top was zero
001286r 1  C8                           iny                             ; Otherwise skip address
001287r 1  C8                           iny
001288r 1  BB C8 C8 7C                  CONTINUE                        ; Done
00128Cr 1  00 00        
00128Er 1               
00128Er 1               ; IMMEDIATE ( -- )
00128Er 1               
00128Er 1  rr rr 80 09                  HEADER  9,"IMMEDIATE",IMMEDIATE
001292r 1  49 4D 4D 45  
001296r 1  44 49 41 54  
00129Br 1  20 rr rr rr                  jsr     DO_COLON
00129Fr 1  rr 80 00 rr  
0012A3r 1  rr rr rr rr  
0012ACr 1                               dw      DO_LITERAL,IMMEDIATE
0012ACr 1                               dw      LATEST
0012ACr 1                               dw      FETCH
0012ACr 1                               dw      ONE_MINUS
0012ACr 1                               dw      C_STORE
0012ACr 1                               dw      EXIT
0012ACr 1               
0012ACr 1               ; LITERAL ( x -- )
0012ACr 1               ;
0012ACr 1               ; Append the run-time semantics given below to the current definition.
0012ACr 1               
0012ACr 1  rr rr 80 07                  HEADER  7,"LITERAL",IMMEDIATE
0012B0r 1  4C 49 54 45  
0012B4r 1  52 41 4C     
0012B7r 1  20 rr rr rr  LITERAL:        jsr     DO_COLON
0012BBr 1  rr rr rr rr  
0012BFr 1  rr rr rr rr  
0012C4r 1                               dw      DO_LITERAL,DO_LITERAL
0012C4r 1                               dw      COMMA
0012C4r 1                               dw      COMMA
0012C4r 1                               dw      EXIT
0012C4r 1               
0012C4r 1               DO_LITERAL:
0012C4r 1  7B                           tdc                             ; Make room on stack
0012C5r 1  3A                           dec     a
0012C6r 1  3A                           dec     a
0012C7r 1  5B                           tcd
0012C8r 1  B9 00 00                     lda     0,y                     ; Fetch constant from IP
0012CBr 1  85 01                        sta     <1
0012CDr 1  C8                           iny
0012CEr 1  C8                           iny
0012CFr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0012D3r 1  00 00        
0012D5r 1               
0012D5r 1               ; LOOP
0012D5r 1               
0012D5r 1  rr rr 80 04                  HEADER  4,"LOOP",IMMEDIATE
0012D9r 1  4C 4F 4F 50  
0012DDr 1  20 rr rr rr  LOOP:           jsr     DO_COLON
0012E1r 1  rr rr rr rr  
0012E5r 1  rr rr rr rr  
0012F4r 1                               dw      DO_LITERAL,DO_LOOP
0012F4r 1                               dw      COMMA
0012F4r 1                               dw      COMMA
0012F4r 1                               dw      QUERY_DUP
0012F4r 1                               dw      QUERY_BRANCH,LOOP_1
0012F4r 1                               dw      HERE
0012F4r 1                               dw      SWAP
0012F4r 1                               dw      STORE
0012F4r 1  rr rr        LOOP_1:         dw      EXIT
0012F6r 1               
0012F6r 1               ; (LOOP)
0012F6r 1               
0012F6r 1               ;               HEADER  6,"(LOOP)",NORMAL
0012F6r 1               DO_LOOP
0012F6r 1  A3 01                        lda     1,s                     ; Add one to loop counter
0012F8r 1  1A                           inc     a
0012F9r 1  83 01                        sta     1,s
0012FBr 1  C3 03                        cmp     3,s                     ; Reached limit?
0012FDr 1  B0 0A                        bcs     DO_LOOP_END             ; Yes
0012FFr 1  B9 00 00                     lda     0,y                     ; No, branch back to start
001302r 1  A8                           tay
001303r 1  BB C8 C8 7C                  CONTINUE                        ; Done
001307r 1  00 00        
001309r 1               
001309r 1  C8           DO_LOOP_END:    iny                             ; Skip over address
00130Ar 1  C8                           iny
00130Br 1  68                           pla                             ; Drop loop variables
00130Cr 1  68                           pla
00130Dr 1  BB C8 C8 7C                  CONTINUE                        ; Done
001311r 1  00 00        
001313r 1               
001313r 1               ; POSTPONE
001313r 1               
001313r 1               ;   BL WORD FIND
001313r 1               ;   DUP 0= ABORT" ?"
001313r 1               ;   0< IF   -- xt       non immed: add code to current
001313r 1               ;                       def'n to compile xt later.
001313r 1               ;       ['] LIT ,XT  ,  add "LIT,xt,COMMAXT"
001313r 1               ;       ['] ,XT ,XT     to current definition
001313r 1               ;   ELSE  ,XT      immed: compile into cur. def'n
001313r 1               ;   THEN ; IMMEDIATE
001313r 1               
001313r 1  rr rr 80 08                  HEADER  8,"POSTPONE",IMMEDIATE
001317r 1  50 4F 53 54  
00131Br 1  50 4F 4E 45  
00131Fr 1  20 rr rr rr  POSTPONE:       jsr     DO_COLON
001323r 1  rr rr rr rr  
001327r 1  rr rr rr rr  
001344r 1                               dw      BL
001344r 1                               dw      WORD
001344r 1                               dw      FIND
001344r 1                               dw      DUP
001344r 1                               dw      ZERO_EQUAL
001344r 1                               dw      DO_S_QUOTE
001344r 1                               db      1,"?"
001344r 1                               dw      QUERY_ABORT
001344r 1                               dw      ZERO_LESS
001344r 1                               dw      QUERY_BRANCH,POSTPONE_1
001344r 1                               dw      DO_LITERAL,DO_LITERAL
001344r 1                               dw      COMMA
001344r 1                               dw      COMMA
001344r 1                               dw      BRANCH,POSTPONE_2
001344r 1  rr rr        POSTPONE_1:     dw      COMMA
001346r 1  rr rr        POSTPONE_2:     dw      EXIT
001348r 1               
001348r 1               ; RECURSE ( -- )
001348r 1               
001348r 1  rr rr 80 07                  HEADER  7,"RECURSE",IMMEDIATE
00134Cr 1  52 45 43 55  
001350r 1  52 53 45     
001353r 1  20 rr rr rr  RECURSE:        jsr     DO_COLON
001357r 1  rr rr rr rr  
00135Br 1  rr rr rr rr  
001360r 1                               dw      LATEST
001360r 1                               dw      FETCH
001360r 1                               dw      NFA_TO_CFA
001360r 1                               dw      COMMA
001360r 1                               dw      EXIT
001360r 1               
001360r 1               ; S"
001360r 1               
001360r 1  rr rr 80 02                  LINK    IMMEDIATE
001364r 1  53 22        
001366r 1                               db      2,"S",'"'
001366r 1  20 rr rr rr  S_QUOTE:        jsr     DO_COLON
00136Ar 1  rr rr rr rr  
00136Er 1  rr rr rr 22  
00137Fr 1                               dw      DO_LITERAL,DO_S_QUOTE
00137Fr 1                               dw      COMMA
00137Fr 1                               dw      DO_LITERAL,'"'
00137Fr 1                               dw      WORD
00137Fr 1                               dw      C_FETCH
00137Fr 1                               dw      ONE_PLUS
00137Fr 1                               dw      ALIGNED
00137Fr 1                               dw      ALLOT
00137Fr 1                               dw      EXIT
00137Fr 1               
00137Fr 1               ; (S") ( -- c-addr u )
00137Fr 1               
00137Fr 1               DO_S_QUOTE:
00137Fr 1  20 rr rr rr                  jsr     DO_COLON
001383r 1  rr rr rr rr  
001387r 1  rr rr rr rr  
001390r 1                               dw      R_FROM
001390r 1                               dw      COUNT
001390r 1                               dw      TWO_DUP
001390r 1                               dw      PLUS
001390r 1                               dw      ALIGNED
001390r 1                               dw      TO_R
001390r 1                               dw      EXIT
001390r 1               
001390r 1               ; THEN ( -- )
001390r 1               
001390r 1  rr rr 80 04                  HEADER  4,"THEN",IMMEDIATE
001394r 1  54 48 45 4E  
001398r 1  20 rr rr rr  THEN:           jsr     DO_COLON
00139Cr 1  rr rr rr rr  
0013A0r 1  rr rr rr     
0013A3r 1                               dw      HERE
0013A3r 1                               dw      SWAP
0013A3r 1                               dw      STORE
0013A3r 1                               dw      EXIT
0013A3r 1               
0013A3r 1               ; UNTIL ( -- )
0013A3r 1               
0013A3r 1  rr rr 80 05                  HEADER  5,"UNTIL",IMMEDIATE
0013A7r 1  55 4E 54 49  
0013ABr 1  4C           
0013ACr 1  20 rr rr rr  UNTIL:          jsr     DO_COLON
0013B0r 1  rr rr rr rr  
0013B4r 1  rr rr rr rr  
0013B9r 1                               dw      DO_LITERAL,QUERY_BRANCH
0013B9r 1                               dw      COMMA
0013B9r 1                               dw      COMMA
0013B9r 1                               dw      EXIT
0013B9r 1               
0013B9r 1               ; USER
0013B9r 1               
0013B9r 1  rr rr 00 04                  HEADER  4,"USER",NORMAL
0013BDr 1  55 53 45 52  
0013C1r 1  20 rr rr rr  USER:           jsr     DO_COLON
0013C5r 1  rr rr rr rr  
0013C9r 1  rr rr rr rr  
0013D0r 1                               dw      CREATE
0013D0r 1                               dw      DO_LITERAL,DO_USER
0013D0r 1                               dw      BUILD
0013D0r 1                               dw      COMMA
0013D0r 1                               dw      EXIT
0013D0r 1               
0013D0r 1  rr rr 00 06                  HEADER  6,"(USER)",NORMAL
0013D4r 1  28 55 53 45  
0013D8r 1  52 29        
0013DAr 1               DO_USER:
0013DAr 1  7B                           tdc
0013DBr 1  3A                           dec     a                       ; Push on data stack
0013DCr 1  3A                           dec     a
0013DDr 1  5B                           tcd
0013DEr 1  FA                           plx
0013DFr 1  18                           clc
0013E0r 1  BD 01 00                     lda     a:1,x
0013E3r 1  69 rr rr                     adc     #USER_AREA
0013E6r 1  85 01                        sta     <1
0013E8r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0013ECr 1  00 00        
0013EEr 1               
0013EEr 1               ; VARIABLE ( <spaces>name -- )
0013EEr 1               ;
0013EEr 1               ; Skip leading space delimiters. Parse name delimited by a space. Create a
0013EEr 1               ; definition for name with the execution semantics defined below. Reserve one
0013EEr 1               ; cell of data space at an aligned address.
0013EEr 1               
0013EEr 1  rr rr 00 08                  LINK    NORMAL
0013F2r 1  56 41 52 49  
0013F6r 1  41 42 4C 45  
0013FAr 1                               db      8,"VARIABLE"
0013FAr 1  20 rr rr rr  VARIABLE:       jsr     DO_COLON
0013FEr 1  rr rr rr rr  
001402r 1  rr rr rr rr  
00140Fr 1                               dw      CREATE
00140Fr 1                               dw      DO_LITERAL,DO_VARIABLE
00140Fr 1                               dw      BUILD
00140Fr 1                               dw      DO_LITERAL,1
00140Fr 1                               dw      CELLS
00140Fr 1                               dw      ALLOT
00140Fr 1                               dw      EXIT
00140Fr 1               
00140Fr 1               DO_VARIABLE:
00140Fr 1  7B                           tdc
001410r 1  3A                           dec     a
001411r 1  3A                           dec     a
001412r 1  5B                           tcd
001413r 1  68                           pla
001414r 1  1A                           inc     a
001415r 1  85 01                        sta     <1
001417r 1  BB C8 C8 7C                  CONTINUE
00141Br 1  00 00        
00141Dr 1               
00141Dr 1               ; WORDS ( -- )
00141Dr 1               ;
00141Dr 1               ;   LATEST @ BEGIN
00141Dr 1               ;       DUP COUNT TYPE SPACE
00141Dr 1               ;       NFA>LFA @
00141Dr 1               ;   DUP 0= UNTIL
00141Dr 1               ;   DROP ;
00141Dr 1               
00141Dr 1  rr rr 00 05                  HEADER  5,"WORDS",NORMAL
001421r 1  57 4F 52 44  
001425r 1  53           
001426r 1  20 rr rr rr                  jsr     DO_COLON
00142Ar 1  rr rr rr     
00142Dr 1                               dw      LATEST
00142Dr 1                               dw      FETCH
00142Dr 1  rr rr rr rr  WORDS_1:        dw      DUP
001431r 1  rr rr rr rr  
001435r 1  rr rr rr rr  
001445r 1                               dw      COUNT
001445r 1                               dw      TYPE
001445r 1                               dw      SPACE
001445r 1                               dw      NFA_TO_LFA
001445r 1                               dw      FETCH
001445r 1                               dw      DUP
001445r 1                               dw      ZERO_EQUAL
001445r 1                               dw      QUERY_BRANCH,WORDS_1
001445r 1                               dw      DROP
001445r 1                               dw      EXIT
001445r 1               
001445r 1               ; [
001445r 1               ;
001445r 1               ; In this implementation it is defined as
001445r 1               ;
001445r 1               ;   0 STATE !
001445r 1               
001445r 1  rr rr 80 01                  HEADER  1,"[",IMMEDIATE
001449r 1  5B           
00144Ar 1  20 rr rr rr  LEFT_BRACKET:   jsr     DO_COLON
00144Er 1  rr rr rr rr  
001452r 1  rr rr rr     
001455r 1                               dw      ZERO
001455r 1                               dw      STATE
001455r 1                               dw      STORE
001455r 1                               dw      EXIT
001455r 1               
001455r 1               ; \ ( -- )
001455r 1               ;
001455r 1               ; Parse and discard the remainder of the parse area. \ is an immediate word.
001455r 1               ;
001455r 1               ; In this implementation it is defined as
001455r 1               ;
001455r 1               ;   1 WORD DROP
001455r 1               
001455r 1  rr rr 80 01                  HEADER  1,"\",IMMEDIATE                 ; extra quote for highlight sanity "
001459r 1  5C           
00145Ar 1  20 rr rr rr  BACKSLASH:      jsr     DO_COLON
00145Er 1  rr 01 00 rr  
001462r 1  rr rr rr rr  
001467r 1                               dw      DO_LITERAL,1
001467r 1                               dw      WORD
001467r 1                               dw      DROP
001467r 1                               dw      EXIT
001467r 1               
001467r 1               ; ]
001467r 1               ;
001467r 1               ; In this implementation it is defined as
001467r 1               ;
001467r 1               ;   -1 STATE !
001467r 1               
001467r 1  rr rr 00 01                  HEADER  1,"]",NORMAL
00146Br 1  5D           
00146Cr 1  20 rr rr rr  RIGHT_BRACKET:  jsr     DO_COLON
001470r 1  rr FF FF rr  
001474r 1  rr rr rr rr  
001479r 1                               dw      DO_LITERAL,$FFFF        ; Was -1
001479r 1                               dw      STATE
001479r 1                               dw      STORE
001479r 1                               dw      EXIT
001479r 1               
001479r 1               ;===============================================================================
001479r 1               ; I/O Operations
001479r 1               ;-------------------------------------------------------------------------------
001479r 1               
001479r 1               ; CR ( -- )
001479r 1               ;
001479r 1               ; Cause subsequent output to appear at the beginning of the next line.
001479r 1               ;
001479r 1               ; In this implementation it is defined as
001479r 1               ;
001479r 1               ;   13 EMIT 10 EMIT
001479r 1               
001479r 1  rr rr 00 02                  HEADER  2,"CR",NORMAL
00147Dr 1  43 52        
00147Fr 1  20 rr rr rr  CR:             jsr     DO_COLON
001483r 1  rr 0D 00 rr  
001487r 1  rr rr rr 0A  
001490r 1                               dw      DO_LITERAL,13
001490r 1                               dw      EMIT
001490r 1                               dw      DO_LITERAL,10
001490r 1                               dw      EMIT
001490r 1                               dw      EXIT
001490r 1               
001490r 1               ; EMIT ( x -- )
001490r 1               ;
001490r 1               ; If x is a graphic character in the implementation-defined character set,
001490r 1               ; display x. The effect of EMIT for all other values of x is implementation
001490r 1               ; -defined.
001490r 1               
001490r 1  rr rr 00 04                  HEADER  4,"EMIT",NORMAL
001494r 1  45 4D 49 54  
001498r 1                               extern  UartTx
001498r 1               EMIT:
001498r 1  A5 01                        lda     <1                      ; Fetch character from stack
00149Ar 1  20 rr rr                     jsr     UartTx                  ; .. and transmit
00149Dr 1  7B                           tdc
00149Er 1  1A                           inc     a                       ; Drop the character
00149Fr 1  1A                           inc     a
0014A0r 1  5B                           tcd
0014A1r 1  BB C8 C8 7C                  CONTINUE                        ; Done
0014A5r 1  00 00        
0014A7r 1               
0014A7r 1               ; KEY ( -- char )
0014A7r 1               ;
0014A7r 1               ; Receive one character char, a member of the implementation-defined character
0014A7r 1               ; set. Keyboard events that do not correspond to such characters are discarded
0014A7r 1               ; until a valid character is received, and those events are subsequently
0014A7r 1               ; unavailable.
0014A7r 1               ;
0014A7r 1               ; All standard characters can be received. Characters received by KEY are not
0014A7r 1               ; displayed.
0014A7r 1               
0014A7r 1  rr rr 00 03                  HEADER  3,"KEY",NORMAL
0014ABr 1  4B 45 59     
0014AEr 1                               extern  UartRx
0014AEr 1               KEY:
0014AEr 1  20 rr rr                     jsr     UartRx                  ; Receive a character
0014B1r 1  29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
0014B4r 1  AA                           tax
0014B5r 1  7B                           tdc
0014B6r 1  3A                           dec     a                       ; And push to stack
0014B7r 1  3A                           dec     a
0014B8r 1  5B                           tcd
0014B9r 1  86 01                        stx     <1
0014BBr 1  BB C8 C8 7C                  CONTINUE                        ; Done
0014BFr 1  00 00        
0014C1r 1               
0014C1r 1               ; SPACE ( -- )
0014C1r 1               ;
0014C1r 1               ; Display one space.
0014C1r 1               ;
0014C1r 1               ; In this implementation it is defined as
0014C1r 1               ;
0014C1r 1               ;   BL EMIT
0014C1r 1               
0014C1r 1  rr rr 00 05                  HEADER  5,"SPACE",NORMAL
0014C5r 1  53 50 41 43  
0014C9r 1  45           
0014CAr 1  20 rr rr rr  SPACE:          jsr     DO_COLON
0014CEr 1  rr rr rr rr  
0014D2r 1  rr           
0014D3r 1                               dw      BL
0014D3r 1                               dw      EMIT
0014D3r 1                               dw      EXIT
0014D3r 1               
0014D3r 1               ; SPACES ( n -- )
0014D3r 1               ;
0014D3r 1               ; If n is greater than zero, display n spaces.
0014D3r 1               ;
0014D3r 1               ; In this implementation it is defined as
0014D3r 1               ;
0014D3r 1               ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
0014D3r 1               
0014D3r 1  rr rr 00 06                  HEADER  6,"SPACES",NORMAL
0014D7r 1  53 50 41 43  
0014DBr 1  45 53        
0014DDr 1  20 rr rr     SPACES:         jsr     DO_COLON
0014E0r 1  rr rr rr rr  SPACES_1:       dw      DUP
0014E4r 1  rr rr rr rr  
0014E8r 1  rr rr rr rr  
0014F0r 1                               dw      ZERO_GREATER
0014F0r 1                               dw      QUERY_BRANCH,SPACES_2
0014F0r 1                               dw      SPACE
0014F0r 1                               dw      ONE_MINUS
0014F0r 1                               dw      BRANCH,SPACES_1
0014F0r 1  rr rr rr rr  SPACES_2:       dw      DROP
0014F4r 1                               dw      EXIT
0014F4r 1               
0014F4r 1               ; TYPE ( c-addr u -- )
0014F4r 1               ;
0014F4r 1               ; If u is greater than zero, display the character string specified by c-addr
0014F4r 1               ; and u.
0014F4r 1               ;
0014F4r 1               ; In this implementation it is defined as
0014F4r 1               ;
0014F4r 1               ;   ?DUP IF
0014F4r 1               ;     OVER + SWAP DO I C@ EMIT LOOP
0014F4r 1               ;   ELSE DROP THEN
0014F4r 1               
0014F4r 1  rr rr 00 04                  HEADER  4,"TYPE",NORMAL
0014F8r 1  54 59 50 45  
0014FCr 1  20 rr rr rr  TYPE:           jsr     DO_COLON
001500r 1  rr rr rr rr  
001504r 1  rr rr rr rr  
00150Dr 1                               dw      QUERY_DUP
00150Dr 1                               dw      QUERY_BRANCH,TYPE_2
00150Dr 1                               dw      OVER
00150Dr 1                               dw      PLUS
00150Dr 1                               dw      SWAP
00150Dr 1                               dw      DO_DO
00150Dr 1  rr rr rr rr  TYPE_1:         dw      I
001511r 1  rr rr rr rr  
001515r 1  rr rr rr rr  
00151Br 1                               dw      C_FETCH
00151Br 1                               dw      EMIT
00151Br 1                               dw      DO_LOOP,TYPE_1
00151Br 1                               dw      BRANCH,TYPE_3
00151Br 1  rr rr        TYPE_2          dw      DROP
00151Dr 1  rr rr        TYPE_3          dw      EXIT
00151Fr 1               
00151Fr 1               ;===============================================================================
00151Fr 1               ; Formatted Output
00151Fr 1               ;-------------------------------------------------------------------------------
00151Fr 1               
00151Fr 1               ; # ( ud1 -- ud2 )
00151Fr 1               ;
00151Fr 1               ; Divide ud1 by the number in BASE giving the quotient ud2 and the remainder n.
00151Fr 1               ; (n is the least-significant digit of ud1.) Convert n to external form and add
00151Fr 1               ; the resulting character to the beginning of the pictured numeric output string.
00151Fr 1               ; An ambiguous condition exists if # executes outside of a <# #> delimited
00151Fr 1               ; number conversion.
00151Fr 1               ;
00151Fr 1               ;       BASE @ >R 0 R@ UM/MOD ROT ROT R> UM/MOD ROT ROT DUP 9 > 7 AND + 30 + HOLD
00151Fr 1               
00151Fr 1  rr rr 00 01                  HEADER  1,"#",NORMAL
001523r 1  23           
001524r 1  20 rr rr rr  HASH:           jsr     DO_COLON
001528r 1  rr rr rr rr  
00152Cr 1  rr rr rr rr  
001559r 1                               dw      BASE
001559r 1                               dw      FETCH
001559r 1                               dw      TO_R
001559r 1                               dw      ZERO
001559r 1                               dw      R_FETCH
001559r 1                               dw      UM_SLASH_MOD
001559r 1                               dw      ROT
001559r 1                               dw      ROT
001559r 1                               dw      R_FROM
001559r 1                               dw      UM_SLASH_MOD
001559r 1                               dw      ROT
001559r 1                               dw      ROT
001559r 1                               dw      DUP
001559r 1                               dw      DO_LITERAL,9
001559r 1                               dw      GREATER
001559r 1                               dw      DO_LITERAL,7
001559r 1                               dw      _AND
001559r 1                               dw      PLUS
001559r 1                               dw      DO_LITERAL,'0'
001559r 1                               dw      PLUS
001559r 1                               dw      HOLD
001559r 1                               dw      EXIT
001559r 1               
001559r 1               ; #> ( xd -- c-addr u )
001559r 1               ;
001559r 1               ; Drop xd. Make the pictured numeric output string available as a character
001559r 1               ; string. c-addr and u specify the resulting character string. A program may
001559r 1               ; replace characters within the string.
001559r 1               ;
001559r 1               ;       2DROP HP @ PAD OVER -
001559r 1               
001559r 1  rr rr 00 02                  HEADER  2,"#>",NORMAL
00155Dr 1  23 3E        
00155Fr 1  20 rr rr rr  HASH_GREATER:   jsr     DO_COLON
001563r 1  rr rr rr rr  
001567r 1  rr rr rr rr  
001570r 1                               dw      TWO_DROP
001570r 1                               dw      HP
001570r 1                               dw      FETCH
001570r 1                               dw      PAD
001570r 1                               dw      OVER
001570r 1                               dw      MINUS
001570r 1                               dw      EXIT
001570r 1               
001570r 1               ; #S ( ud1 -- ud2 )
001570r 1               ;
001570r 1               ; Convert one digit of ud1 according to the rule for #. Continue conversion
001570r 1               ; until the quotient is zero. ud2 is zero. An ambiguous condition exists if #S
001570r 1               ; executes outside of a <# #> delimited number conversion.
001570r 1               ;
001570r 1               ;       BEGIN # 2DUP OR 0= UNTIL
001570r 1               
001570r 1  rr rr 00 02                  HEADER  2,"#S",NORMAL
001574r 1  23 53        
001576r 1  20 rr rr     HASH_S:         jsr     DO_COLON
001579r 1  rr rr rr rr  HASH_S_1:       dw      HASH
00157Dr 1  rr rr rr rr  
001581r 1  rr rr rr rr  
001587r 1                               dw      TWO_DUP
001587r 1                               dw      OR
001587r 1                               dw      ZERO_EQUAL
001587r 1                               dw      QUERY_BRANCH,HASH_S_1
001587r 1                               dw      EXIT
001587r 1               
001587r 1               ; . ( n -- )
001587r 1               ;
001587r 1               ; Display n in free field format.
001587r 1               ;
001587r 1               ;       <# DUP ABS 0 #S ROT SIGN #> TYPE SPACE
001587r 1               
001587r 1  rr rr 00 01                  HEADER  1,".",NORMAL
00158Br 1  2E           
00158Cr 1  20 rr rr rr  DOT:            jsr     DO_COLON
001590r 1  rr rr rr rr  
001594r 1  rr rr rr rr  
0015A5r 1                               dw      LESS_HASH
0015A5r 1                               dw      DUP
0015A5r 1                               dw      ABS
0015A5r 1                               dw      ZERO
0015A5r 1                               dw      HASH_S
0015A5r 1                               dw      ROT
0015A5r 1                               dw      SIGN
0015A5r 1                               dw      HASH_GREATER
0015A5r 1                               dw      TYPE
0015A5r 1                               dw      SPACE
0015A5r 1                               dw      EXIT
0015A5r 1               
0015A5r 1               ; <# ( -- )
0015A5r 1               ;
0015A5r 1               ; Initialize the pictured numeric output conversion process.
0015A5r 1               ;
0015A5r 1               ;       PAD HP !
0015A5r 1               
0015A5r 1  rr rr 00 02                  HEADER  2,"<#",NORMAL
0015A9r 1  3C 23        
0015ABr 1  20 rr rr rr  LESS_HASH:      jsr     DO_COLON
0015AFr 1  rr rr rr rr  
0015B3r 1  rr rr rr     
0015B6r 1                               dw      PAD
0015B6r 1                               dw      HP
0015B6r 1                               dw      STORE
0015B6r 1                               dw      EXIT
0015B6r 1               
0015B6r 1               ; HOLD ( char -- )
0015B6r 1               
0015B6r 1               ; Add char to the beginning of the pictured numeric output string. An
0015B6r 1               ; ambiguous condition exists if HOLD executes outside of a <# #> delimited
0015B6r 1               ; number conversion.
0015B6r 1               ;
0015B6r 1               ;       -1 HP +!  HP @ C!
0015B6r 1               
0015B6r 1  rr rr 00 04                  HEADER  4,"HOLD",NORMAL
0015BAr 1  48 4F 4C 44  
0015BEr 1  20 rr rr rr  HOLD:           jsr     DO_COLON
0015C2r 1  rr FF FF rr  
0015C6r 1  rr rr rr rr  
0015D1r 1                               dw      DO_LITERAL,$FFFF        ; Was -1
0015D1r 1                               dw      HP
0015D1r 1                               dw      PLUS_STORE
0015D1r 1                               dw      HP
0015D1r 1                               dw      FETCH
0015D1r 1                               dw      C_STORE
0015D1r 1                               dw      EXIT
0015D1r 1               
0015D1r 1               ; PAD ( -- c-addr )
0015D1r 1               ;
0015D1r 1               ; c-addr is the address of a transient region that can be used to hold data
0015D1r 1               ; for intermediate processing.
0015D1r 1               
0015D1r 1  rr rr 00 03                  HEADER  3,"PAD",NORMAL
0015D5r 1  50 41 44     
0015D8r 1  20 rr rr rr  PAD:            jsr     DO_CONSTANT
0015DCr 1  rr           
0015DDr 1                               dw      PAD_AREA
0015DDr 1               
0015DDr 1               ; SIGN ( n -- )
0015DDr 1               ;
0015DDr 1               ; If n is negative, add a minus sign to the beginning of the pictured numeric
0015DDr 1               ; output string. An ambiguous condition exists if SIGN executes outside of a
0015DDr 1               ; <# #> delimited number conversion.
0015DDr 1               ;
0015DDr 1               ;       [ HEX ] 0< IF 2D HOLD THEN
0015DDr 1               
0015DDr 1  rr rr 00 04                  HEADER  4,"SIGN",NORMAL
0015E1r 1  53 49 47 4E  
0015E5r 1  20 rr rr rr  SIGN:           jsr     DO_COLON
0015E9r 1  rr rr rr rr  
0015EDr 1  rr rr rr 2D  
0015F4r 1                               dw      ZERO_LESS
0015F4r 1                               dw      QUERY_BRANCH,SIGN_1
0015F4r 1                               dw      DO_LITERAL,'-'
0015F4r 1                               dw      HOLD
0015F4r 1  rr rr        SIGN_1:         dw      EXIT
0015F6r 1               
0015F6r 1               ; U. ( u -- )
0015F6r 1               ;
0015F6r 1               ; Display u in free field format.
0015F6r 1               ;
0015F6r 1               ;  <# 0 #S #> TYPE SPACE
0015F6r 1               
0015F6r 1  rr rr 00 02                  HEADER  2,"U.",NORMAL
0015FAr 1  55 2E        
0015FCr 1  20 rr rr rr  U_DOT:          jsr     DO_COLON
001600r 1  rr rr rr rr  
001604r 1  rr rr rr rr  
00160Dr 1                               dw      LESS_HASH
00160Dr 1                               dw      ZERO
00160Dr 1                               dw      HASH_S
00160Dr 1                               dw      HASH_GREATER
00160Dr 1                               dw      TYPE
00160Dr 1                               dw      SPACE
00160Dr 1                               dw      EXIT
00160Dr 1               
00160Dr 1               ;===============================================================================
00160Dr 1               ; Programming Tools
00160Dr 1               ;-------------------------------------------------------------------------------
00160Dr 1               
00160Dr 1               ; .NYBBLE ( n -- )
00160Dr 1               ;
00160Dr 1               ; Print the least significant nybble of the top value on the stack in hex.
00160Dr 1               
00160Dr 1               ;               HEADER  7,".NYBBLE",NORMAL
00160Dr 1               DOT_NYBBLE:
00160Dr 1  A5 01                        lda     <1
00160Fr 1  29 0F 00                     and     #$000f
001612r 1  09 30 00                     ora     #$0030
001615r 1  C9 3A 00                     cmp     #$003a
001618r 1  90 03                        bcc     $+5
00161Ar 1  69 06 00                     adc     #$0006
00161Dr 1  20 rr rr                     jsr     UartTx
001620r 1  4C rr rr                     jmp     DROP
001623r 1               
001623r 1               ; .BYTE ( n -- )
001623r 1               ;
001623r 1               ; Print least significant byte of top value on the stack in hex followed by
001623r 1               ; a space.
001623r 1               
001623r 1  rr rr 00 05                  HEADER  5,".BYTE",NORMAL
001627r 1  2E 42 59 54  
00162Br 1  45           
00162Cr 1  20 rr rr rr  DOT_BYTE:       jsr     DO_COLON
001630r 1  rr rr rr 04  
001634r 1  00 rr rr rr  
00163Fr 1                               dw      DUP
00163Fr 1                               dw      DO_LITERAL,4
00163Fr 1                               dw      RSHIFT
00163Fr 1                               dw      DOT_NYBBLE
00163Fr 1                               dw      DOT_NYBBLE
00163Fr 1                               dw      SPACE
00163Fr 1                               dw      EXIT
00163Fr 1               
00163Fr 1               ; .WORD ( n -- )
00163Fr 1               ;
00163Fr 1               ; Print the top value on the stack in hex followed by a space.
00163Fr 1               
00163Fr 1  rr rr 00 05                  HEADER  5,".WORD",NORMAL
001643r 1  2E 57 4F 52  
001647r 1  44           
001648r 1  20 rr rr rr  DOT_WORD:       jsr     DO_COLON
00164Cr 1  rr rr rr 0C  
001650r 1  00 rr rr rr  
00166Fr 1                               dw      DUP
00166Fr 1                               dw      DO_LITERAL,12
00166Fr 1                               dw      RSHIFT
00166Fr 1                               dw      DOT_NYBBLE
00166Fr 1                               dw      DUP
00166Fr 1                               dw      DO_LITERAL,8
00166Fr 1                               dw      RSHIFT
00166Fr 1                               dw      DOT_NYBBLE
00166Fr 1                               dw      DUP
00166Fr 1                               dw      DO_LITERAL,4
00166Fr 1                               dw      RSHIFT
00166Fr 1                               dw      DOT_NYBBLE
00166Fr 1                               dw      DOT_NYBBLE
00166Fr 1                               dw      SPACE
00166Fr 1                               dw      EXIT
00166Fr 1               
00166Fr 1               ; .DP
00166Fr 1               
00166Fr 1  rr rr 00 03                  HEADER  3,".DP",NORMAL
001673r 1  2E 44 50     
001676r 1  20 rr rr rr                  jsr     DO_COLON
00167Ar 1  rr rr rr rr  
00167Er 1  rr           
00167Fr 1                               dw      AT_DP
00167Fr 1                               dw      DOT_WORD
00167Fr 1                               dw      EXIT
00167Fr 1               
00167Fr 1  rr rr 00 03                  HEADER  3,".RP",NORMAL
001683r 1  2E 52 50     
001686r 1  20 rr rr rr                  jsr     DO_COLON
00168Ar 1  rr rr rr rr  
00168Er 1  rr           
00168Fr 1                               dw      AT_RP
00168Fr 1                               dw      DOT_WORD
00168Fr 1                               dw      EXIT
00168Fr 1               
00168Fr 1               ; .S ( -- )
00168Fr 1               ;
00168Fr 1               ; Copy and display the values currently on the data stack. The format of the
00168Fr 1               ; display is implementation-dependent.
00168Fr 1               
00168Fr 1  rr rr 00 02                  HEADER  2,".S",NORMAL
001693r 1  2E 53        
001695r 1  20 rr rr rr                  jsr     DO_COLON
001699r 1  rr 7B 00 rr  
00169Dr 1  rr rr rr rr  
0016AEr 1               		dw	DO_LITERAL,'{'
0016AEr 1               		dw	EMIT
0016AEr 1               		dw	SPACE
0016AEr 1                               dw      AT_DP
0016AEr 1                               dw      ONE_PLUS
0016AEr 1                               dw      DO_LITERAL,DSTACK_END
0016AEr 1                               dw      SWAP
0016AEr 1                               dw      QUERY_DO_DO,DOT_S_2
0016AEr 1  rr rr rr rr  DOT_S_1:        dw      I
0016B2r 1  rr rr rr rr  
0016B6r 1  02 00 rr rr  
0016BCr 1                               dw      FETCH
0016BCr 1                               dw      DOT_WORD
0016BCr 1                               dw      DO_LITERAL,2
0016BCr 1                               dw      DO_PLUS_LOOP
0016BCr 1                               dw      DOT_S_1
0016BCr 1  rr rr 7D 00  DOT_S_2:	dw	DO_LITERAL,'}'
0016C0r 1  rr rr rr rr  
0016C4r 1  rr rr        
0016C6r 1               		dw	EMIT
0016C6r 1               		dw	SPACE
0016C6r 1                               dw      EXIT
0016C6r 1               
0016C6r 1               ; ? ( a-addr -- )
0016C6r 1               ;
0016C6r 1               ; Display the value stored at a-addr.
0016C6r 1               
0016C6r 1  rr rr 00 01                  HEADER  1,"?",NORMAL
0016CAr 1  3F           
0016CBr 1  20 rr rr rr                  jsr     DO_COLON
0016CFr 1  rr rr rr rr  
0016D3r 1  rr           
0016D4r 1                               dw      FETCH
0016D4r 1                               dw      DOT_WORD
0016D4r 1                               dw      EXIT
0016D4r 1               
0016D4r 1  rr rr 00 03                  HEADER  3,"@DP",NORMAL
0016D8r 1  40 44 50     
0016DBr 1               AT_DP:
0016DBr 1  0B                           phd
0016DCr 1  7B                           tdc
0016DDr 1  3A                           dec     a
0016DEr 1  3A                           dec     a
0016DFr 1  5B                           tcd
0016E0r 1  68                           pla
0016E1r 1  85 01                        sta     <1
0016E3r 1  BB C8 C8 7C                  CONTINUE
0016E7r 1  00 00        
0016E9r 1               
0016E9r 1  rr rr 00 03                  HEADER  3,"@RP",NORMAL
0016EDr 1  40 52 50     
0016F0r 1               AT_RP:
0016F0r 1  7B                           tdc
0016F1r 1  3A                           dec     a
0016F2r 1  3A                           dec     a
0016F3r 1  5B                           tcd
0016F4r 1  BA                           tsx
0016F5r 1  86 01                        stx     <1
0016F7r 1  BB C8 C8 7C                  CONTINUE
0016FBr 1  00 00        
0016FDr 1               
0016FDr 1               
0016FDr 1               ;-------------------------------------------------------------------------------
0016FDr 1               
0016FDr 1                               include "device.asm"
0016FDr 2               ;==============================================================================
0016FDr 2               ;     _    _   _ ____    _____          _   _       _  ___  _  __
0016FDr 2               ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
0016FDr 2               ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
0016FDr 2               ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
0016FDr 2               ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
0016FDr 2               ;
0016FDr 2               ; Device Specific Words for the W65C816SXB
0016FDr 2               ;------------------------------------------------------------------------------
0016FDr 2               ; Copyright (C)2015-2016 HandCoded Software Ltd.
0016FDr 2               ; All rights reserved.
0016FDr 2               ;
0016FDr 2               ; This work is made available under the terms of the Creative Commons
0016FDr 2               ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
0016FDr 2               ; following URL to see the details.
0016FDr 2               ;
0016FDr 2               ; http://creativecommons.org/licenses/by-nc-sa/4.0/
0016FDr 2               ;
0016FDr 2               ;==============================================================================
0016FDr 2               ; Notes:
0016FDr 2               ;
0016FDr 2               ;------------------------------------------------------------------------------
0016FDr 2               
0016FDr 2               ; (TITLE) - ( -- )
0016FDr 2               ;
0016FDr 2               
0016FDr 2               ;               HEADER  7,"(TITLE)",NORMAL
0016FDr 2  20 rr rr rr  DO_TITLE:       jsr     DO_COLON
001701r 2  rr 1C 57 36  
001705r 2  35 43 38 31  
001721r 2                               dw      DO_S_QUOTE
001721r 2                               db      28,"W65C816SXB ANS-Forth [16.05]"
001721r 2                               dw      EXIT
001721r 2               
001721r 2               ; BYE ( -- )
001721r 2               ;
001721r 2               ; Return control to the host operating system, if any.
001721r 2               
001721r 2  rr rr 00 03                  HEADER  3,"BYE",NORMAL
001725r 2  42 59 45     
001728r 2               BYE:
001728r 2  78                           sei
001729r 2  D8                           cld
00172Ar 2  38 FB                        emulate
00172Cr 2  6C FC FF                     jmp     ($fffc)         ; Reset the processor
00172Fr 2               
00172Fr 2               ; UNUSED ( -- u )
00172Fr 2               ;
00172Fr 2               ; u is the amount of space remaining in the region addressed by HERE , in
00172Fr 2               ; address units.
00172Fr 2               
00172Fr 2  rr rr 00 06                  HEADER  6,"UNUSED",NORMAL
001733r 2  55 4E 55 53  
001737r 2  45 44        
001739r 2  20 rr rr rr  UNUSED:         jsr     DO_COLON
00173Dr 2  rr 00 7E rr  
001741r 2  rr rr rr rr  
001746r 2                               dw      DO_LITERAL,$7e00
001746r 2                               dw      HERE
001746r 2                               dw      MINUS
001746r 2                               dw      EXIT
001746r 2               
001746r 2               ;-------------------------------------------------------------------------------
001746r 2               
001746r 2  rr rr 00 08                  HEADER  8,"ACIA$RXD",NORMAL
00174Ar 2  41 43 49 41  
00174Er 2  24 52 58 44  
001752r 2  20 rr rr 80                  jsr     DO_CONSTANT
001756r 2  7F           
001757r 2                               dw      $7f80
001757r 2               
001757r 2  rr rr 00 08                  HEADER  8,"ACIA$TXD",NORMAL
00175Br 2  41 43 49 41  
00175Fr 2  24 54 58 44  
001763r 2  20 rr rr 80                  jsr     DO_CONSTANT
001767r 2  7F           
001768r 2                               dw      $7f80
001768r 2               
001768r 2  rr rr 00 07                  HEADER  7,"ACIA$SR",NORMAL
00176Cr 2  41 43 49 41  
001770r 2  24 53 52     
001773r 2  20 rr rr 81                  jsr     DO_CONSTANT
001777r 2  7F           
001778r 2                               dw      $7f81
001778r 2               
001778r 2  rr rr 00 08                  HEADER  8,"ACIA$CMD",NORMAL
00177Cr 2  41 43 49 41  
001780r 2  24 43 4D 44  
001784r 2  20 rr rr 82                  jsr     DO_CONSTANT
001788r 2  7F           
001789r 2                               dw      $7f82
001789r 2               
001789r 2  rr rr 00 08                  HEADER  8,"ACIA$CTL",NORMAL
00178Dr 2  41 43 49 41  
001791r 2  24 43 54 4C  
001795r 2  20 rr rr 83                  jsr     DO_CONSTANT
001799r 2  7F           
00179Ar 2                               dw      $7f83
00179Ar 2               
00179Ar 2               ;-------------------------------------------------------------------------------
00179Ar 2               
00179Ar 2  rr rr 00 07                  HEADER  7,"PIA$PIA",NORMAL
00179Er 2  50 49 41 24  
0017A2r 2  50 49 41     
0017A5r 2  20 rr rr A0                  jsr     DO_CONSTANT
0017A9r 2  7F           
0017AAr 2                               dw      $7fa0
0017AAr 2               
0017AAr 2  rr rr 00 08                  HEADER  8,"PIA$DDRA",NORMAL
0017AEr 2  50 49 41 24  
0017B2r 2  44 44 52 41  
0017B6r 2  20 rr rr A0                  jsr     DO_CONSTANT
0017BAr 2  7F           
0017BBr 2                               dw      $7fa0
0017BBr 2               
0017BBr 2  rr rr 00 07                  HEADER  7,"PIA$CRA",NORMAL
0017BFr 2  50 49 41 24  
0017C3r 2  43 52 41     
0017C6r 2  20 rr rr A1                  jsr     DO_CONSTANT
0017CAr 2  7F           
0017CBr 2                               dw      $7fa1
0017CBr 2               
0017CBr 2  rr rr 00 07                  HEADER  7,"PIA$PIB",NORMAL
0017CFr 2  50 49 41 24  
0017D3r 2  50 49 42     
0017D6r 2  20 rr rr A2                  jsr     DO_CONSTANT
0017DAr 2  7F           
0017DBr 2                               dw      $7fa2
0017DBr 2               
0017DBr 2  rr rr 00 08                  HEADER  8,"PIA$DDRB",NORMAL
0017DFr 2  50 49 41 24  
0017E3r 2  44 44 52 42  
0017E7r 2  20 rr rr A2                  jsr     DO_CONSTANT
0017EBr 2  7F           
0017ECr 2                               dw      $7fa2
0017ECr 2               
0017ECr 2  rr rr 00 07                  HEADER  7,"PIA$CRB",NORMAL
0017F0r 2  50 49 41 24  
0017F4r 2  43 52 42     
0017F7r 2  20 rr rr A3                  jsr     DO_CONSTANT
0017FBr 2  7F           
0017FCr 2                               dw      $7fa3
0017FCr 2               
0017FCr 2               ;-------------------------------------------------------------------------------
0017FCr 2               
0017FCr 2  rr rr 00 08                  HEADER  8,"VIA1$ORB",NORMAL
001800r 2  56 49 41 31  
001804r 2  24 4F 52 42  
001808r 2  20 rr rr C0                  jsr     DO_CONSTANT
00180Cr 2  7F           
00180Dr 2                               dw      $7fc0
00180Dr 2               
00180Dr 2  rr rr 00 08                  HEADER  8,"VIA1$IRB",NORMAL
001811r 2  56 49 41 31  
001815r 2  24 49 52 42  
001819r 2  20 rr rr C0                  jsr     DO_CONSTANT
00181Dr 2  7F           
00181Er 2                               dw      $7fc0
00181Er 2               
00181Er 2  rr rr 00 08                  HEADER  8,"VIA1$ORA",NORMAL
001822r 2  56 49 41 31  
001826r 2  24 4F 52 41  
00182Ar 2  20 rr rr C1                  jsr     DO_CONSTANT
00182Er 2  7F           
00182Fr 2                               dw      $7fc1
00182Fr 2               
00182Fr 2  rr rr 00 08                  HEADER  8,"VIA1$IRA",NORMAL
001833r 2  56 49 41 31  
001837r 2  24 49 52 41  
00183Br 2  20 rr rr C1                  jsr     DO_CONSTANT
00183Fr 2  7F           
001840r 2                               dw      $7fc1
001840r 2               
001840r 2  rr rr 00 09                  HEADER  9,"VIA1$DDRB",NORMAL
001844r 2  56 49 41 31  
001848r 2  24 44 44 52  
00184Dr 2  20 rr rr C2                  jsr     DO_CONSTANT
001851r 2  7F           
001852r 2                               dw      $7fc2
001852r 2               
001852r 2  rr rr 00 09                  HEADER  9,"VIA1$DDRA",NORMAL
001856r 2  56 49 41 31  
00185Ar 2  24 44 44 52  
00185Fr 2  20 rr rr C3                  jsr     DO_CONSTANT
001863r 2  7F           
001864r 2                               dw      $7fc3
001864r 2               
001864r 2  rr rr 00 09                  HEADER  9,"VIA1$T1CL",NORMAL
001868r 2  56 49 41 31  
00186Cr 2  24 54 31 43  
001871r 2  20 rr rr C4                  jsr     DO_CONSTANT
001875r 2  7F           
001876r 2                               dw      $7fc4
001876r 2               
001876r 2  rr rr 00 09                  HEADER  9,"VIA1$T1CH",NORMAL
00187Ar 2  56 49 41 31  
00187Er 2  24 54 31 43  
001883r 2  20 rr rr C5                  jsr     DO_CONSTANT
001887r 2  7F           
001888r 2                               dw      $7fc5
001888r 2               
001888r 2  rr rr 00 09                  HEADER  9,"VIA1$T1LL",NORMAL
00188Cr 2  56 49 41 31  
001890r 2  24 54 31 4C  
001895r 2  20 rr rr C6                  jsr     DO_CONSTANT
001899r 2  7F           
00189Ar 2                               dw      $7fc6
00189Ar 2               
00189Ar 2  rr rr 00 09                  HEADER  9,"VIA1$T1LH",NORMAL
00189Er 2  56 49 41 31  
0018A2r 2  24 54 31 4C  
0018A7r 2  20 rr rr C7                  jsr     DO_CONSTANT
0018ABr 2  7F           
0018ACr 2                               dw      $7fc7
0018ACr 2               
0018ACr 2  rr rr 00 09                  HEADER  9,"VIA1$T2CL",NORMAL
0018B0r 2  56 49 41 31  
0018B4r 2  24 54 32 43  
0018B9r 2  20 rr rr C8                  jsr     DO_CONSTANT
0018BDr 2  7F           
0018BEr 2                               dw      $7fc8
0018BEr 2               
0018BEr 2  rr rr 00 09                  HEADER  9,"VIA1$T2CH",NORMAL
0018C2r 2  56 49 41 31  
0018C6r 2  24 54 32 43  
0018CBr 2  20 rr rr C9                  jsr     DO_CONSTANT
0018CFr 2  7F           
0018D0r 2                               dw      $7fc9
0018D0r 2               
0018D0r 2  rr rr 00 07                  HEADER  7,"VIA1$SR",NORMAL
0018D4r 2  56 49 41 31  
0018D8r 2  24 53 52     
0018DBr 2  20 rr rr CA                  jsr     DO_CONSTANT
0018DFr 2  7F           
0018E0r 2                               dw      $7fca
0018E0r 2               
0018E0r 2  rr rr 00 08                  HEADER  8,"VIA1$ACR",NORMAL
0018E4r 2  56 49 41 31  
0018E8r 2  24 41 43 52  
0018ECr 2  20 rr rr CB                  jsr     DO_CONSTANT
0018F0r 2  7F           
0018F1r 2                               dw      $7fcb
0018F1r 2               
0018F1r 2  rr rr 00 08                  HEADER  8,"VIA1$PCR",NORMAL
0018F5r 2  56 49 41 31  
0018F9r 2  24 50 43 52  
0018FDr 2  20 rr rr CC                  jsr     DO_CONSTANT
001901r 2  7F           
001902r 2                               dw      $7fcc
001902r 2               
001902r 2  rr rr 00 08                  HEADER  8,"VIA1$IFR",NORMAL
001906r 2  56 49 41 31  
00190Ar 2  24 49 46 52  
00190Er 2  20 rr rr CD                  jsr     DO_CONSTANT
001912r 2  7F           
001913r 2                               dw      $7fcd
001913r 2               
001913r 2  rr rr 00 08                  HEADER  8,"VIA1$IER",NORMAL
001917r 2  56 49 41 31  
00191Br 2  24 49 45 52  
00191Fr 2  20 rr rr CE                  jsr     DO_CONSTANT
001923r 2  7F           
001924r 2                               dw      $7fce
001924r 2               
001924r 2  rr rr 00 09                  HEADER  9,"VIA1$ORAN",NORMAL
001928r 2  56 49 41 31  
00192Cr 2  24 4F 52 41  
001931r 2  20 rr rr CF                  jsr     DO_CONSTANT
001935r 2  7F           
001936r 2                               dw      $7fcf
001936r 2               
001936r 2  rr rr 00 09                  HEADER  9,"VIA1$IRAN",NORMAL
00193Ar 2  56 49 41 31  
00193Er 2  24 49 52 41  
001943r 2  20 rr rr CF                  jsr     DO_CONSTANT
001947r 2  7F           
001948r 2                               dw      $7fcf
001948r 2               
001948r 2               ;-------------------------------------------------------------------------------
001948r 2               
001948r 2               
001948r 2  rr rr 00 08                  HEADER  8,"VIA2$ORB",NORMAL
00194Cr 2  56 49 41 32  
001950r 2  24 4F 52 42  
001954r 2  20 rr rr E0                  jsr     DO_CONSTANT
001958r 2  7F           
001959r 2                               dw      $7fe0
001959r 2               
001959r 2  rr rr 00 08                  HEADER  8,"VIA2$IRB",NORMAL
00195Dr 2  56 49 41 32  
001961r 2  24 49 52 42  
001965r 2  20 rr rr E0                  jsr     DO_CONSTANT
001969r 2  7F           
00196Ar 2                               dw      $7fe0
00196Ar 2               
00196Ar 2  rr rr 00 08                  HEADER  8,"VIA2$ORA",NORMAL
00196Er 2  56 49 41 32  
001972r 2  24 4F 52 41  
001976r 2  20 rr rr E1                  jsr     DO_CONSTANT
00197Ar 2  7F           
00197Br 2                               dw      $7fe1
00197Br 2               
00197Br 2  rr rr 00 08                  HEADER  8,"VIA2$IRA",NORMAL
00197Fr 2  56 49 41 32  
001983r 2  24 49 52 41  
001987r 2  20 rr rr E1                  jsr     DO_CONSTANT
00198Br 2  7F           
00198Cr 2                               dw      $7fe1
00198Cr 2               
00198Cr 2  rr rr 00 09                  HEADER  9,"VIA2$DDRB",NORMAL
001990r 2  56 49 41 32  
001994r 2  24 44 44 52  
001999r 2  20 rr rr E2                  jsr     DO_CONSTANT
00199Dr 2  7F           
00199Er 2                               dw      $7fe2
00199Er 2               
00199Er 2  rr rr 00 09                  HEADER  9,"VIA2$DDRA",NORMAL
0019A2r 2  56 49 41 32  
0019A6r 2  24 44 44 52  
0019ABr 2  20 rr rr E3                  jsr     DO_CONSTANT
0019AFr 2  7F           
0019B0r 2                               dw      $7fe3
0019B0r 2               
0019B0r 2  rr rr 00 09                  HEADER  9,"VIA2$T1CL",NORMAL
0019B4r 2  56 49 41 32  
0019B8r 2  24 54 31 43  
0019BDr 2  20 rr rr E4                  jsr     DO_CONSTANT
0019C1r 2  7F           
0019C2r 2                               dw      $7fe4
0019C2r 2               
0019C2r 2  rr rr 00 09                  HEADER  9,"VIA2$T1CH",NORMAL
0019C6r 2  56 49 41 32  
0019CAr 2  24 54 31 43  
0019CFr 2  20 rr rr E5                  jsr     DO_CONSTANT
0019D3r 2  7F           
0019D4r 2                               dw      $7fe5
0019D4r 2               
0019D4r 2  rr rr 00 09                  HEADER  9,"VIA2$T1LL",NORMAL
0019D8r 2  56 49 41 32  
0019DCr 2  24 54 31 4C  
0019E1r 2  20 rr rr E6                  jsr     DO_CONSTANT
0019E5r 2  7F           
0019E6r 2                               dw      $7fe6
0019E6r 2               
0019E6r 2  rr rr 00 09                  HEADER  9,"VIA2$T1LH",NORMAL
0019EAr 2  56 49 41 32  
0019EEr 2  24 54 31 4C  
0019F3r 2  20 rr rr E7                  jsr     DO_CONSTANT
0019F7r 2  7F           
0019F8r 2                               dw      $7fe7
0019F8r 2               
0019F8r 2  rr rr 00 09                  HEADER  9,"VIA2$T2CL",NORMAL
0019FCr 2  56 49 41 32  
001A00r 2  24 54 32 43  
001A05r 2  20 rr rr E8                  jsr     DO_CONSTANT
001A09r 2  7F           
001A0Ar 2                               dw      $7fe8
001A0Ar 2               
001A0Ar 2  rr rr 00 09                  HEADER  9,"VIA2$T2CH",NORMAL
001A0Er 2  56 49 41 32  
001A12r 2  24 54 32 43  
001A17r 2  20 rr rr E9                  jsr     DO_CONSTANT
001A1Br 2  7F           
001A1Cr 2                               dw      $7fe9
001A1Cr 2               
001A1Cr 2  rr rr 00 07                  HEADER  7,"VIA2$SR",NORMAL
001A20r 2  56 49 41 32  
001A24r 2  24 53 52     
001A27r 2  20 rr rr EA                  jsr     DO_CONSTANT
001A2Br 2  7F           
001A2Cr 2                               dw      $7fea
001A2Cr 2               
001A2Cr 2  rr rr 00 08                  HEADER  8,"VIA2$ACR",NORMAL
001A30r 2  56 49 41 32  
001A34r 2  24 41 43 52  
001A38r 2  20 rr rr EB                  jsr     DO_CONSTANT
001A3Cr 2  7F           
001A3Dr 2                               dw      $7feb
001A3Dr 2               
001A3Dr 2  rr rr 00 08                  HEADER  8,"VIA2$PCR",NORMAL
001A41r 2  56 49 41 32  
001A45r 2  24 50 43 52  
001A49r 2  20 rr rr EC                  jsr     DO_CONSTANT
001A4Dr 2  7F           
001A4Er 2                               dw      $7fec
001A4Er 2               
001A4Er 2  rr rr 00 08                  HEADER  8,"VIA2$IFR",NORMAL
001A52r 2  56 49 41 32  
001A56r 2  24 49 46 52  
001A5Ar 2  20 rr rr ED                  jsr     DO_CONSTANT
001A5Er 2  7F           
001A5Fr 2                               dw      $7fed
001A5Fr 2               
001A5Fr 2  rr rr 00 08                  HEADER  8,"VIA2$IER",NORMAL
001A63r 2  56 49 41 32  
001A67r 2  24 49 45 52  
001A6Br 2  20 rr rr EE                  jsr     DO_CONSTANT
001A6Fr 2  7F           
001A70r 2                               dw      $7fee
001A70r 2               
001A70r 2  rr rr 00 09                  HEADER  9,"VIA2$ORAN",NORMAL
001A74r 2  56 49 41 32  
001A78r 2  24 4F 52 41  
001A7Dr 2  20 rr rr EF                  jsr     DO_CONSTANT
001A81r 2  7F           
001A82r 2                               dw      $7fef
001A82r 2               
001A82r 2  rr rr 00 09                  HEADER  9,"VIA2$IRAN",NORMAL
001A86r 2  56 49 41 32  
001A8Ar 2  24 49 52 41  
001A8Fr 2  20 rr rr EF                  jsr     DO_CONSTANT
001A93r 2  7F           
001A94r 2                               dw      $7fef
001A94r 2               
001A94r 1               
001A94r 1                               TRAILER
001A94r 1               NEXT_WORD:
001A94r 1               
001A94r 1                               end
001A94r 1               
